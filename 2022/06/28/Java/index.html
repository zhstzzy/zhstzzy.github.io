

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.jpg">
  <link rel="icon" href="/img/favicon.ico">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="zhstzzy">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言、入门程序、常量、变量 常用DOS命令 常用命令    命令 操作符号    盘符切换命令 盘符名：   查看当前文件夹 dir   进入文件夹命令 cd 文件夹名   退出文件夹命令 cd..   退出到磁盘根目录 cd\   清屏 cls     Java虚拟机——JVM JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="http://example.com/2022/06/28/Java/index.html">
<meta property="og:site_name" content="Yuan&#39;s Note">
<meta property="og:description" content="前言、入门程序、常量、变量 常用DOS命令 常用命令    命令 操作符号    盘符切换命令 盘符名：   查看当前文件夹 dir   进入文件夹命令 cd 文件夹名   退出文件夹命令 cd..   退出到磁盘根目录 cd\   清屏 cls     Java虚拟机——JVM JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/java.jpg">
<meta property="article:published_time" content="2022-06-28T11:51:21.000Z">
<meta property="article:modified_time" content="2022-07-09T08:17:45.563Z">
<meta property="article:author" content="zhstzzy">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/java.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>java - Yuan&#39;s Note</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuan&#39;s Note</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" target="_blank" rel="noopener" href="https://pan.zhstzzy.com">
                
                Yuan's Cloud
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="java"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-06-28 19:51" pubdate>
          2022年6月28日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          91k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          756 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="前言、入门程序、常量、变量"><a href="#前言、入门程序、常量、变量" class="headerlink" title="前言、入门程序、常量、变量"></a>前言、入门程序、常量、变量</h1><hr>
<h3 id="常用DOS命令"><a href="#常用DOS命令" class="headerlink" title="常用DOS命令"></a>常用DOS命令</h3><ul>
<li><p><strong>常用命令</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th>操作符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">盘符切换命令</td>
<td><code>盘符名：</code></td>
</tr>
<tr>
<td align="left">查看当前文件夹</td>
<td><code>dir</code></td>
</tr>
<tr>
<td align="left">进入文件夹命令</td>
<td><code>cd 文件夹名</code></td>
</tr>
<tr>
<td align="left">退出文件夹命令</td>
<td><code>cd..</code></td>
</tr>
<tr>
<td align="left">退出到磁盘根目录</td>
<td><code>cd\</code></td>
</tr>
<tr>
<td align="left">清屏</td>
<td><code>cls</code></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="Java虚拟机——JVM"><a href="#Java虚拟机——JVM" class="headerlink" title="Java虚拟机——JVM"></a>Java虚拟机——JVM</h3><ul>
<li><p><strong>JVM</strong>（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的 运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 </p>
</li>
<li><p><strong>跨平台</strong>：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系 统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM 运行在操作系统上。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/JVM.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
<h3 id="JRE和JDK"><a href="#JRE和JDK" class="headerlink" title="JRE和JDK"></a>JRE和JDK</h3><ul>
<li><p><strong>JRE</strong> ( Java Runtime Environment) ：是Java程序的运行时环境，包含<code>JVM</code>和运行时所需要的<code>核心类库</code>  </p>
</li>
<li><p><strong>JDK</strong> ( Java Development Kit)：是Java程序开发工具包，<code>包含JRE和开发人员使用的工具</code>。</p>
</li>
</ul>
<p>我们想要运行一个已有的Java程序，<code>那么只需安装JRE即可</code><br>我们想要开发一个全新的Java程序，<code>那么必须安装JDK</code></p>
<blockquote>
<p>小提示：<br>三者关系： JDK &gt; JRE &gt; JVM</p>
</blockquote>
<h3 id="程序开发步骤说明"><a href="#程序开发步骤说明" class="headerlink" title="程序开发步骤说明"></a>程序开发步骤说明</h3><p>Java程序的三个步骤：<strong>编写</strong>、<strong>编译</strong>、<strong>运行</strong>。</p>
<ul>
<li><strong>编写</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>编译</strong></li>
</ul>
<p>在DOS命令行中，<strong>进入java源文件的目录</strong>，使用<code>javac</code>命令进行编译。</p>
<p>命令：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span><span class="hljs-keyword">java源文件名.后缀名</span><br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>HelloWorld.<span class="hljs-keyword">java</span><br></code></pre></td></tr></table></figure>

<p>编译成功后，命令行没有任何提示。打开 目录，发现产生了一个新的文件 <code>HelloWorld.class</code> ，该文件 就是编译后的文件，是Java的可运行文件，称为字节码文件，有了<strong>字节码文件</strong>，就可以运行程序了。</p>
<blockquote>
<p>Java<code>源文件的编译工具javac。exe</code>，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以在任意目录下使用。</p>
</blockquote>
<ul>
<li><strong>运行</strong></li>
</ul>
<p>在DOS命令行中，<strong>进入java源文件的目录</strong>，使用<code>java</code>命令进行运行。</p>
<p>命令：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">java </span>关键字<br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">java HelloWorld</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>Java HelloWorrld 不要写 不要写 不要写 .class</p>
<p>Java程序<code>.class文件</code>的运行工具<code>java.exe</code>，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以在任意目录下使用。</p>
</blockquote>
<h3 id="入门程序说明"><a href="#入门程序说明" class="headerlink" title="入门程序说明"></a>入门程序说明</h3><ol>
<li><p><strong>编译和运行是俩回事</strong></p>
<ul>
<li><strong>编译</strong>：是指将我们编写的java源文件翻译成JVM认识的class文件，在这个过程中，<code>javac</code>编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没用错误就会编译成功。</li>
<li><strong>运行</strong>：是指将<code>class文件</code>交给JVM去运行，此时JVM就会去执行我们编写的程序了。</li>
</ul>
</li>
<li><p><strong>关于main方法</strong></p>
<ul>
<li><strong>main方法</strong>：称为主方法。写法是<strong>固定格式</strong>不可以更改。main方法是程序的入口点或者起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。</li>
</ul>
</li>
<li><p><strong>添加注释comment</strong></p>
<ul>
<li><p><strong>注释</strong>：就是对代码的解释和说明。其目的是让人们能够更加轻松的了解代码。为代码加注释，是十分重要的，他不影响程序的编译和运行。</p>
</li>
<li><p>Java中有实现注释（包括单行注释和多行注释）和文档注释</p>
<ul>
<li><p>单行注释以 <code>//开头 换行结束</code></p>
</li>
<li><p>多行注释以 <code>/*开头 以*/结束</code></p>
</li>
<li><p>文档注释以 <code>/**开头 以*/结束</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">*对程序、类和变量的解释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>关键字keywords</strong></p>
<ul>
<li><strong>关键字</strong>：是指在程序中，Java已经定义好的单词，具有特殊含义。<ul>
<li>HelloWorld案例中，出现的关键字有<code>public</code>、<code>class</code>、<code>static</code>、<code>void</code>等，这些单词已经被Java定义好，全部是小写字母，notepad++中颜色特殊。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>关键字比较多，不能死记硬背，学到哪里记到哪里即可。</li>
</ul>
<p>常用关键字</p>
<table>
<thead>
<tr>
<th><strong><code>abstract</code></strong></th>
<th><strong><code>else</code></strong></th>
<th><strong><code>interface</code></strong></th>
<th><strong><code>super</code></strong></th>
<th><strong><code>char</code></strong></th>
<th><strong><code>for</code></strong></th>
<th><strong><code>private</code></strong></th>
<th><strong><code>transient</code></strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>extends</code></td>
<td><code>long</code></td>
<td><code>switch</code></td>
<td><code>class</code></td>
<td><code>if</code></td>
<td><code>protected</code></td>
<td><code>try</code></td>
</tr>
<tr>
<td><code>break</code></td>
<td><code>false</code></td>
<td><code>native</code></td>
<td><code>synchronized</code></td>
<td><code>continue</code></td>
<td><code>implements</code></td>
<td><code>public</code></td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>final</code></td>
<td><code>new</code></td>
<td><code>this</code></td>
<td><code>default</code></td>
<td><code>import</code></td>
<td><code>return</code></td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>case</code></td>
<td><code>finally</code></td>
<td><code>null</code></td>
<td><code>throw</code></td>
<td><code>do</code></td>
<td><code>instanceof</code></td>
<td><code>short</code></td>
<td><code>Volatile</code></td>
</tr>
<tr>
<td><code>catch</code></td>
<td><code>float</code></td>
<td><code>package</code></td>
<td><code>throws</code></td>
<td><code>double</code></td>
<td><code>int</code></td>
<td><code>static</code></td>
<td><code>While</code></td>
</tr>
</tbody></table>
<ol>
<li><strong>标识符</strong><ul>
<li><strong>标识符</strong>：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。<ul>
<li>HelloWorld案例中，出现的标识符有类名字 <code>HelloWorld</code> 。</li>
</ul>
</li>
<li><strong>命名规则： <code>硬性要求</code></strong><ul>
<li>标识符可以包含<code>英文字母26个(区分大小写)</code> 、<code>0-9数字</code> 、<code>$（美元符号）</code> 和 <code>_（下划线）</code> 。</li>
<li>标识符不能以数字开头。</li>
<li>标识符不能是关键字。</li>
</ul>
</li>
<li><strong>命名规范：<code>软性建议</code></strong><ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</li>
<li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</li>
<li>变量名规范：全部小写。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>常量：在程序运行期间，固定不变的量。</strong></p>
<p><strong>常量的分类</strong></p>
<ol>
<li>字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：”<code>abc</code>“、”<code>Hello</code>“、”<code>123</code>“</li>
<li>整数常量：直接写上的数字，没有小数点。例如：<code>100</code>、<code>200</code>、<code>0</code>、<code>-250</code></li>
<li>浮点数常量：直接写上的数字，有小数点。例如：<code>2.5</code>、<code>-3.14</code>、<code>0.0</code></li>
<li>字符常量：凡是用单引号引起来的单个字符，就做字符常量。例如：’<code>A</code>‘、’<code>b</code>‘、’<code>9</code>‘、’<code>中</code>‘</li>
<li>布尔常量：只有量中取值。<code>true</code>、<code>false</code>。</li>
<li>空常量：<code>null</code>。代表没有任何数据。</li>
</ol>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>含义</strong></th>
<th><strong>数据举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>整数常量</td>
<td>所有的整数</td>
<td>0，1， 567， -9</td>
</tr>
<tr>
<td>小数常量</td>
<td>所有的小数</td>
<td>0.0， -0.1， 2.55</td>
</tr>
<tr>
<td>字符常量</td>
<td>单引号引起来,只能写一个字符,必须有内容</td>
<td>‘a’ ， ‘ ‘， ‘好’</td>
</tr>
<tr>
<td>字符串常量</td>
<td>双引号引起来,可以写多个字符,也可以不写</td>
<td>“A” ，”Hello” ，”你好” ，””</td>
</tr>
<tr>
<td>布尔常量</td>
<td>只有两个值（流程控制中讲解）</td>
<td>true ， false</td>
</tr>
<tr>
<td>空常量</td>
<td>只有一个值（引用数据类型中讲解）</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><strong>变量：程序运行期间，内容可以发生改变的量。</strong></li>
</ul>
<blockquote>
<p>数学中，可以使用字母代替数字运算,例如 x&#x3D;1+5 或者 6&#x3D;x+5。 </p>
<p>程序中，可以使用字母保存数字的方式进行运算，提高计算能力，可以解决更多的问题。比如x保存5，x也可 以保存6，这样x保存的数据是可以改变的，也就是我们所讲解的变量。</p>
</blockquote>
<p>Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><strong>数据类型分类</strong></p>
<p>Java的数据类型分为两大类：</p>
<ul>
<li><strong>基本数据类型</strong>：包括 <code>整数</code> 、<code>浮点数</code> 、<code>字符</code> 、<code>布尔</code> 。</li>
<li><strong>引用数据类型</strong>：包括 <code>类</code>、<code>数组</code>、<code>接口</code>。</li>
</ul>
<p><strong>基本数据类型</strong></p>
<p>四类八种基本数据类型：</p>
<table>
<thead>
<tr>
<th><strong>数据类型</strong></th>
<th><strong>关键字</strong></th>
<th><strong>占用内存</strong></th>
<th><strong>取值范围</strong></th>
</tr>
</thead>
<tbody><tr>
<td>字节型</td>
<td><code>byte</code></td>
<td>1个字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>短整型</td>
<td><code>short</code></td>
<td>2个字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>整形</td>
<td><code>int</code>（默认）</td>
<td>4个字节</td>
<td>-2^31^~2^31^-1</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td>-2^63^~2^63^-1</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>float</td>
<td>4个字节</td>
<td>-3.4E38（3.4×10^38^）~3.4E38（3.4×10^38^）</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double（默认）</td>
<td>8个字节</td>
<td>-1.7E308（1.7×10^308^）~1.7E308（1.7×10^308^）</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2个字节</td>
<td>任意字符（0-65535）</td>
</tr>
<tr>
<td>布尔类型</td>
<td>boolean</td>
<td>1个字节</td>
<td>true，false</td>
</tr>
</tbody></table>
<blockquote>
<p>Java中的默认类型：整数类型是 <code>int</code> 、浮点类型是 <code>double</code> 。</p>
</blockquote>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>变量定义的格式包括三个要素： <code>数据类型</code> 、 <code>变量名</code> 、 <code>数据值</code> 。</p>
<p><strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = 数据值;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>long类型：建议数据后加L表示。</p>
<p>float类型：建议数据后加F表示。</p>
</blockquote>
<p><strong>使用变量的时候，有一些注意事项：</strong></p>
<ol>
<li>如果创建多个变量，那么变量之间的名称不可以重复。</li>
<li>对于<code>float</code>和<code>long</code>类型来说，字母后缀F和L不要丢掉。</li>
<li>如果使用<code>byte</code>或者<code>short</code>类型的变量，那么右侧的数据值不能超过左侧类型的范围。</li>
<li>没有进行赋值的变量，不能直接使用；一定要赋值之后，才能使用。</li>
<li>变量使用不能超过作用域的范围。<br>【作用域】：从定义变量的一行开始，一直到直接所属的大括号结束为止。</li>
<li>可以通过一个语句来创建多个变量，但是一般情况不推荐这么写。</li>
</ol>
<h1 id="数据类型转换、运算符、方法入门"><a href="#数据类型转换、运算符、方法入门" class="headerlink" title="数据类型转换、运算符、方法入门"></a>数据类型转换、运算符、方法入门</h1><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><hr>
<p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p>
<h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><ul>
<li><strong>自动转换</strong>：将<code>取值范围小的类型</code>自动提升为<code>取值范围大的类型</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// byte x = b + i; // 报错</span><br>    <span class="hljs-comment">//int类型和byte类型运算，结果是int类型</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> b + i;<br>    System.out.println(j);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>转换原理图解</strong></p>
<p><code>byte</code> 类型内存占有1个字节，在和 <code>int</code> 类型运算时会提升为<code>int</code> 类型 ，自动补充3个字节，因此计算后的结果还是 <code>int</code> 类 型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png" srcset="/img/loading.gif" lazyload></p>
<p>同样道理，当一个 <code>int</code> 类型变量和一个 <code>double</code> 变量运算时， <code>int</code> 类型将会自动提升为 <code>double</code> 类型进行运算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.5</span>;<br>    <span class="hljs-comment">//int类型和double类型运算，结果是double类型</span><br>    <span class="hljs-comment">//int类型会提升为double类型</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> d+i;<br>    System.out.println(e);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>转换规则</strong> </p>
<p>范围小的类型向范围大的类型提升， <code>byte</code>、<code>short</code>、<code>char</code> 运算时直接提升为 <code>int</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>、<span class="hljs-type">short</span>、<span class="hljs-type">char</span>‐‐&gt;<span class="hljs-type">int</span>‐‐&gt;<span class="hljs-type">long</span>‐‐&gt;<span class="hljs-type">float</span>‐‐&gt;<span class="hljs-type">double</span><br></code></pre></td></tr></table></figure>

<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><p>将 <code>1.5</code> 赋值到 <code>int</code> 类型变量会发生什么？产生编译失败，肯定无法赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.5</span>; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure>

<p><code>double</code> 类型内存8个字节， <code>int</code> 类型内存4个字节。 <code>1.5</code> 是 <code>double</code> 类型，取值范围大于 <code>int</code> 。可以理解为 <code>double</code> 是8 升的水壶， <code>int</code> 是4升的水壶，不能把大水壶中的水直接放进小水壶去。</p>
<p>想要赋值成功，只有通过强制类型转换，将 <code>double</code> 类型强制转换成 <code>int</code> 类型才能赋值。</p>
<ul>
<li><strong>强制类型转换</strong>：将 <code>取值范围大的类型</code>强制转换成 <code>取值范围小的类型</code>。</li>
</ul>
<p>比较而言，自动转换是Java自动执行的，而强制转换需要我们自己手动执行。</p>
<p><strong>转换格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = （数据类型）被转数据值；<br></code></pre></td></tr></table></figure>

<p>将 <code>1.5</code> 赋值到 <code>int</code> 类型，代码修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// double类型数据强制转成int类型，直接去掉小数点。</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">1.5</span>;<br></code></pre></td></tr></table></figure>

<p>同样道理，当一个 <code>short</code> 类型与 <code>1</code> 相加，我们知道会类型提升，但是还想给结果赋值给<code>short</code>类型变量，就需要强制转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//short类型变量，内存中2个字节</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">       出现编译失败</span><br><span class="hljs-comment">       s和1做运算的时候，1是int类型，s会被提升为int类型</span><br><span class="hljs-comment">       s+1后的结果是int类型，将结果在赋值会short类型时发生错误</span><br><span class="hljs-comment">       short内存2个字节，int类型4个字节</span><br><span class="hljs-comment">       必须将int强制转成short才能完成赋值</span><br><span class="hljs-comment">    */</span><br>    s = s + <span class="hljs-number">1</span>；<span class="hljs-comment">//编译失败</span><br>    s = (<span class="hljs-type">short</span>)(s+<span class="hljs-number">1</span>);<span class="hljs-comment">//编译成功</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>转换原理图解</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png" srcset="/img/loading.gif" lazyload></p>
<p>&#x3D;&#x3D;<strong>强烈注意</strong>&#x3D;&#x3D;</p>
<ul>
<li>浮点转成整数，直接取消小数点，可能造成数据损失精度。</li>
<li><code>int</code> 强制转成 <code>short</code> 砍掉2个字节，可能造成数据丢失。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义s为short范围内最大值</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">32767</span>;<br><span class="hljs-comment">// 运算后，强制转换，砍掉2个字节后会出现不确定的结果</span><br>s = (<span class="hljs-type">short</span>)(s + <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<h3 id="ASCII编码表"><a href="#ASCII编码表" class="headerlink" title="ASCII编码表"></a>ASCII编码表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//字符类型变量</span><br>    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//字符类型和int类型计算</span><br>    System.out.println(c+i);<span class="hljs-comment">//输出结果是98</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在计算机的内部都是二进制的0、1数据，如何让计算机可以直接识别人类文字的问题呢？就产生出了编码表的概念。</p>
<ul>
<li><p><strong>编码表</strong>：就是将人类的文字和一个十进制数进行对应起来组成一张表格。</p>
<p>人们就规定:</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">48</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">57</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center">Z</td>
<td align="center">90</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">97</td>
</tr>
<tr>
<td align="center">z</td>
<td align="center">122</td>
</tr>
</tbody></table>
<ul>
<li>将所有的英文字母，数字，符号都和十进制进行了对应，因此产生了世界上第一张编码表ASCII（ American Standard Code for Information Interchange 美国标准信息交换码）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>小贴士</p>
<p>在char类型和int类型计算的过程中，char类型的字符先查询编码表，得到97，再和1求和，结果为98。char类型提升 为了int类型。char类型内存2个字节，int类型内存4个字节。</p>
</blockquote>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th align="left"><strong>算术运算符包括</strong>：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>+</code></td>
<td>加法运算，字符串连接运算</td>
</tr>
<tr>
<td align="left"><code>-</code></td>
<td>减法运算</td>
</tr>
<tr>
<td align="left"><code>*</code></td>
<td>乘法运算</td>
</tr>
<tr>
<td align="left"><code>/</code></td>
<td>除法运算</td>
</tr>
<tr>
<td align="left"><code>%</code></td>
<td>取模运算，两个数字相除取余数</td>
</tr>
<tr>
<td align="left"><code>++</code>、<code>--</code></td>
<td>自增自减运算</td>
</tr>
</tbody></table>
<p>Java中，整数使用以上运算符，无论怎么计算，也不会得到小数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br>    System.out.println(i/<span class="hljs-number">1000</span>*<span class="hljs-number">1000</span>);<span class="hljs-comment">//计算结果是1000</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>++</code><strong>运算，变量自己增长1</strong>。反之， <code>--</code> 运算，变量自己减少1，用法与 <code>++</code> 一致。</p>
<ul>
<li><p>独立运算：</p>
<ul>
<li>变量在独立运算时， 前<code>++</code> 和后<code>++</code> 没有区别 。</li>
<li>变量 <code>前++</code> ：例如 <code>++i</code> 。</li>
<li>变量 <code>后++</code> ：例如 <code>i++</code> 。</li>
</ul>
</li>
<li><p>混合运算：</p>
<ul>
<li>和其他变量放在一起， <code>前++</code> 和 <code>后++</code> 就产生了不同。</li>
<li>变量 <code>前++</code> ：变量a自己加1，将加1后的结果赋值给b，也就是说a先计算。a和b的结果都是2。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ++a;<br>    System.out.println(a);<span class="hljs-comment">//计算结果是2</span><br>    System.out.println(b);<span class="hljs-comment">//计算结果是2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>变量 <code>后++</code> ：变量a先把自己的值1，赋值给变量b，此时变量b的值就是1，变量a自己再加1。a的结果是2，b 的结果是1。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a++;<br>    System.out.println(a);<span class="hljs-comment">//计算结果是2</span><br>    System.out.println(b);<span class="hljs-comment">//计算结果是1</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>+</code> 符号在 字符串中的操作：</p>
<ul>
<li><code>+</code> 符号在字符串的时候，表示<strong>连接、拼接</strong>的含义。</li>
<li>“a”+”b”的结果是”ab”,连接含义。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;5+5=&quot;</span>+<span class="hljs-number">5</span>+<span class="hljs-number">5</span>);<span class="hljs-comment">//输出5+5=55</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>比较运算符包括：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>等于号</td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加等于</td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减等于</td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘等于</td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除等于</td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模等</td>
</tr>
</tbody></table>
<ul>
<li>赋值运算符，就是将符号右边的值，赋给左边的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    i+=<span class="hljs-number">5</span>;<span class="hljs-comment">//计算方式 i=i+5 变量i先加5，再赋值变量i</span><br>    System.out.println(i); <span class="hljs-comment">//输出结果是10</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>注意事项：<br>1. 只有变量才能使用赋值运算符，常量不能进行赋值。<br>2. 复合赋值运算符其中隐含了一个强制类型转换。</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table>
<thead>
<tr>
<th>比较运算符包括：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>比较符号两边数据是否相等，相等结果是true。</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>比较符号左边的数据是否小于右边的数据，如果小于结果是true。</td>
</tr>
<tr>
<td>&gt;</td>
<td>比较符号左边的数据是否大于右边的数据，如果大于结果是true。</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>比较符号左边的数据是否小于或者等于右边的数据，如果小于结果是true。</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>比较符号左边的数据是否大于或者等于右边的数据，如果小于结果是true。</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于符号 ，如果符号两边的数据不相等，结果是true。</td>
</tr>
</tbody></table>
<ul>
<li>比较运算符，是两个数据之间进行比较的运算，运算结果都是布尔值 <code>true</code> 或者 <code>false</code> 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-number">1</span>==<span class="hljs-number">1</span>);<span class="hljs-comment">//true</span><br>    System.out.println(<span class="hljs-number">1</span>&lt;<span class="hljs-number">2</span>);<span class="hljs-comment">//true</span><br>    System.out.println(<span class="hljs-number">3</span>&gt;<span class="hljs-number">4</span>);<span class="hljs-comment">//false</span><br>    System.out.println(<span class="hljs-number">3</span>&lt;=<span class="hljs-number">4</span>);<span class="hljs-comment">//true</span><br>    System.out.println(<span class="hljs-number">3</span>&gt;=<span class="hljs-number">4</span>);<span class="hljs-comment">//false</span><br>    System.out.println(<span class="hljs-number">3</span>!=<span class="hljs-number">4</span>);<span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意事项：</p>
<p>1.比较运算符的结果一定是一个boolean值，成立就是true，不成立就是false</p>
<p>2.如果进行多次判断，不能连着写。<br>数学当中的写法，例如：1 &lt; x &lt; 3<br>程序当中【不允许】这种写法。</p>
</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>逻辑运算符包括：</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code> 短路与</td>
<td>1. 两边都是true，结果是true<br />2. 一边是false，结果是false <br />短路特点：符号左边是false，右边不再运算</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
</tr>
<tr>
<td><code>！</code> 取反</td>
<td>1. ! true 结果是false <br/>2. ! false结果是true</td>
</tr>
</tbody></table>
<ul>
<li>逻辑运算符，是用来连接两个布尔类型结果的运算符，运算结果都是布尔值 <code>true</code> 或者 <code>false</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    System.out.println(<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br>    System.out.println(<span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">false</span>);<span class="hljs-comment">//false</span><br>    System.out.println(<span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-literal">true</span>);<span class="hljs-comment">//false，右边不计算</span><br>    System.out.println(<span class="hljs-literal">false</span> || <span class="hljs-literal">false</span>);<span class="hljs-comment">//falase</span><br>    System.out.println(<span class="hljs-literal">false</span> || <span class="hljs-literal">true</span>);<span class="hljs-comment">//true</span><br>    System.out.println(<span class="hljs-literal">true</span> || <span class="hljs-literal">false</span>);<span class="hljs-comment">//true，右边不计算</span><br>    System.out.println(!<span class="hljs-literal">false</span>);<span class="hljs-comment">//true</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意事项：</p>
<p>1.逻辑运算符只能用于boolean值。</p>
<p>2.与、或需要左右各自有一个boolean值，但是取反只要有唯一的一个boolean值即可。</p>
<p>3.与、或两种运算符，如果有多个条件，可以连续写。<br>两个条件：条件A &amp;&amp; 条件B<br>多个条件：条件A &amp;&amp; 条件B &amp;&amp; 条件C</p>
</li>
</ul>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><ul>
<li>三元运算符格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = 布尔类型表达式？结果<span class="hljs-number">1</span>：结果<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>三元运算符计算方式：<ul>
<li>布尔类型表达式结果是true，三元运算符整体结果为结果1，赋值给变量。</li>
<li>布尔类型表达式结果是false，三元运算符整体结果为结果2，赋值给变量。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span>==<span class="hljs-number">2</span> ? <span class="hljs-number">100</span> : <span class="hljs-number">200</span>);<br>    System.out.println(i);<span class="hljs-comment">//200</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> (<span class="hljs-number">3</span>&lt;=<span class="hljs-number">4</span> ? <span class="hljs-number">500</span> : <span class="hljs-number">600</span>);<br>    System.out.println(j);<span class="hljs-comment">//500</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="方法入门"><a href="#方法入门" class="headerlink" title="方法入门"></a>方法入门</h2><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且 重复的代码过多。能否避免这些重复的代码呢，就需要使用方法来实现。</p>
<ul>
<li><strong>方法</strong>：就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</li>
</ul>
<p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。</p>
<h3 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h3><ul>
<li>定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名 （参数列表）｛<br>    代码...<br>    <span class="hljs-keyword">return</span> ;<br>｝<br></code></pre></td></tr></table></figure>

<ul>
<li><p>定义格式解释：</p>
<ul>
<li>修饰符：目前固定写法 <code>public static</code> 。</li>
<li>返回值类型：目前固定写法 <code>void</code> 。</li>
<li>方法名：为我们定义的方法起名，满足标识符的规范，用来调用方法。</li>
<li>参数列表： 目前无参数， 带有参数的方法在后面的课程讲解。</li>
<li>return：方法结束。因为返回值类型是void，方法大括号内的return可以不写。</li>
</ul>
</li>
<li><p>举例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodName</span><span class="hljs-params">()</span> &#123;<br>	System.out.println(<span class="hljs-string">&quot;这是一个方法&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法main中来调用我们自己定义好的方法。在 主方法中，直接写要调用的方法名字就可以调用了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//调用定义的方法method</span><br>    method();<br>&#125;<br><span class="hljs-comment">//定义方法，被main方法调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>	System.out.println(<span class="hljs-string">&quot;自己定义的方法，需要被main调用运行&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>方法定义注意事项：<ul>
<li>方法必须定义在一类中方法外。</li>
<li>方法不能定义在另一个方法的里面。</li>
</ul>
</li>
</ul>
<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><hr>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。也就是说，程序的流程对运行结果 有直接的影响。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现 我们要完成的功能。</p>
<h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-comment">//顺序执行，根据编写的顺序，从上到下运行</span><br>    System.out.println(<span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><hr>
<h3 id="判断语句1–if"><a href="#判断语句1–if" class="headerlink" title="判断语句1–if"></a>判断语句1–if</h3><ul>
<li><strong>if语句第一种格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式)｛<br>    语句体;<br>｝<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong><ul>
<li>首先判断关系表达式看结果是<code>true</code>还是 <code>false</code></li>
<li>如果是<code>true</code>就执行语句体</li>
<li>如果是<code>false</code>就不执行</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%8D%95if%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="判断语句2–if…else"><a href="#判断语句2–if…else" class="headerlink" title="判断语句2–if…else"></a>判断语句2–if…else</h3><ul>
<li><strong>if语句第二种格式： if…else</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(关系表达式)&#123;<br>    语句体A；<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    语句体B；<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>执行流程<ul>
<li>首先判断关系表达式看起结果是<code>true</code>还是<code>false</code></li>
<li>如果是<code>true</code>就执行语句体A</li>
<li>如果是<code>false</code>就执行语句体B</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%A0%87%E5%87%86if-else%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p>3.2.3 判断语句3–if..else if…else</p>
<ul>
<li><strong>if语句第三种格式</strong>： if…else if …else</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">1</span>) &#123;<br>	执行语句<span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件<span class="hljs-number">2</span>) &#123;<br>	执行语句<span class="hljs-number">2</span>;<br>&#125;<br>...<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (判断条件n) &#123;<br>	执行语句n;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	执行语句n+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong><ul>
<li>首先判断关系表达式1看其结果是<code>true</code>还是<code>false</code></li>
<li>如果是<code>true</code>就执行语句体1</li>
<li>如果是<code>false</code>就继续判断关系表达式2看其结果是<code>true</code>还是<code>false</code></li>
<li>如果是<code>true</code>就执行语句体2</li>
<li>如果是<code>false</code>就继续判断关系表达式…看其结果是<code>true</code>还是<code>false</code></li>
<li>…</li>
<li>如果没有任何关系表达式为<code>true</code>，就执行语句体n+1。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%89%A9%E5%B1%95if-else%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><hr>
<h3 id="选择语句–switch"><a href="#选择语句–switch" class="headerlink" title="选择语句–switch"></a>选择语句–switch</h3><ul>
<li><strong>switch语句格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">switch</span>(表达式) &#123;<br>  <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">1</span>:<br>	语句体<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> 常量值<span class="hljs-number">2</span>:<br>	语句体<span class="hljs-number">2</span>;<br>	<span class="hljs-keyword">break</span>;<br>  ...<br>  <span class="hljs-keyword">default</span>:<br>	语句体n+<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong><ul>
<li>首先计算出表达式的值</li>
<li>其次，和<code>case</code>依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到break就会结 束。</li>
<li>最后，如果所有的<code>case</code>都和表达式的值不匹配，就会执行<code>default</code>语句体部分，然后程序结束掉。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/switch%E8%AF%AD%E5%8F%A5.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>小提示</p>
<p>switch语句中，表达式的数据类型，可以是byte，short，int，char，enum（枚举），JDK7后可以接收字符串。</p>
</blockquote>
<h3 id="case的穿透性"><a href="#case的穿透性" class="headerlink" title="case的穿透性"></a><code>case</code>的穿透性</h3><p>在switch语句中，如果case的后面不写break，将出现穿透现象，也就是不会在判断下一个case的值，直接向后运 行，直到遇到break，或者整体switch结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>	<span class="hljs-keyword">switch</span> (i)&#123;<br>	  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>		System.out.println(<span class="hljs-string">&quot;执行case0&quot;</span>);<br>		<span class="hljs-keyword">break</span>;<br>	  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>		System.out.println(<span class="hljs-string">&quot;执行case5&quot;</span>);<br>	  <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>		System.out.println(<span class="hljs-string">&quot;执行case10&quot;</span>);<br>	  <span class="hljs-keyword">default</span>:<br>		System.out.println(<span class="hljs-string">&quot;执行default&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述程序中，执行case5后，由于没有break语句，程序会一直向后走，不会在判断case，也不会理会break，直接 运行完整体switch。</p>
<p> &#x3D;&#x3D;由于case存在穿透性，因此初学者在编写switch语句时，必须要写上break。&#x3D;&#x3D;</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><hr>
<h3 id="循环概述"><a href="#循环概述" class="headerlink" title="循环概述"></a>循环概述</h3><p>循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为false，从而结束循环，否则循环将一直执行下去，形成死循环。</p>
<h3 id="循环语句1–for"><a href="#循环语句1–for" class="headerlink" title="循环语句1–for"></a>循环语句1–for</h3><ul>
<li><strong>for循环语句格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化表达式①; 布尔表达式②; 步进表达式④)&#123;<br>	循环体③<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong><ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。</li>
<li>①负责完成循环变量初始化</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环</li>
<li>③具体执行的语句 </li>
<li>④循环后，循环条件所涉及变量的变化情况</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/for%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="循环语句2–while"><a href="#循环语句2–while" class="headerlink" title="循环语句2–while"></a>循环语句2–while</h3><ul>
<li><strong>while循环语句格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化表达式①<br><span class="hljs-keyword">while</span>(布尔表达式②)&#123;<br>	循环体③<br>	步进表达式④<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong><ul>
<li>执行顺序：①②③④&gt;②③④&gt;②③④…②不满足为止。 </li>
<li>①负责完成循环变量初始化。</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环。 </li>
<li>③具体执行的语句。</li>
<li>④循环后，循环变量的变化情况。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/while%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="循环语句3–do…while"><a href="#循环语句3–do…while" class="headerlink" title="循环语句3–do…while"></a>循环语句3–do…while</h3><ul>
<li><strong>do…while循环格式</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">初始化表达式①<br>	<span class="hljs-keyword">do</span>&#123;<br>	循环体③<br>	步进表达式④<br>&#125;<span class="hljs-keyword">while</span>(布尔表达式②);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>执行流程</strong><ul>
<li>执行顺序：①③④&gt;②③④&gt;②③④…②不满足为止。</li>
<li>①负责完成循环变量初始化。</li>
<li>②负责判断是否满足循环条件，不满足则跳出循环。</li>
<li>③具体执行的语句 </li>
<li>④循环后，循环变量的变化情况</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/do%E2%80%A6while%E5%BE%AA%E7%8E%AF.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="循环语句的区别"><a href="#循环语句的区别" class="headerlink" title="循环语句的区别"></a>循环语句的区别</h3><ul>
<li><code>for</code> 和 <code>while</code> 的小区别： <ul>
<li>控制条件语句所控制的那个变量，在<code>for</code>循环结束后，就不能再被访问到了，而<code>while</code>循环结束还可以继 续使用，如果你想继续使用，就用<code>while</code>，否则推荐使用<code>for</code>。原因是<code>for</code>循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 </li>
<li>在已知循环次数的时候使用推荐使用<code>for</code>，循环次数未知的时推荐使用<code>while</code>。</li>
</ul>
</li>
</ul>
<h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><p>&#x3D;&#x3D;<strong>break</strong>&#x3D;&#x3D;</p>
<ul>
<li><strong>使用场景：终止switch或者循环</strong><ul>
<li>在选择结构switch语句中 </li>
<li>在循环语句中 </li>
<li>离开使用场景的存在是没有意义的</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;<strong>continue</strong>&#x3D;&#x3D;</p>
<ul>
<li><strong>使用场景：结束本次循环，继续下一次的循环</strong></li>
</ul>
<h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><hr>
<h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><ul>
<li><strong>死循环：</strong>也就是循环中的条件永远为<code>true</code>，死循环的是永不结束的循环。例如：<code>while(true)&#123;&#125;</code>。</li>
</ul>
<p>在后期的开发中，会出现使用死循环的场景，例如：我们需要读取用户输入的输入，但是用户输入多少数据我们并 不清楚，也只能使用死循环，当用户不想输入数据了，就可以结束循环了，如何去结束一个死循环呢，就需要使用 到跳出语句了。</p>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><ul>
<li><strong>所谓嵌套循环</strong>，是指一个循环的循环体是另一个循环。比如for循环里面还有一个for循环，就是嵌套循环。总 共的循环次数&#x3D;外循环次数*内循环次数</li>
<li><strong>嵌套循环格式：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(初始化表达式①; 循环条件②; 步进表达式⑦) &#123;<br>	<span class="hljs-keyword">for</span>(初始化表达式③; 循环条件④; 步进表达式⑥) &#123;<br>		执行语句⑤;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>嵌套循环执行流程：</strong><ul>
<li>执行顺序：①②③④⑤⑥&gt;④⑤⑥&gt;⑦②③④⑤⑥&gt;④⑤⑥ </li>
<li>外循环一次，内循环多次。 </li>
<li>比如跳绳：一共跳5组，每组跳10个。5组就是外循环，10个就是内循环。</li>
</ul>
</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><hr>
<p><strong>IDEA常用快捷键</strong></p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>Alt+Enter</code></td>
<td>导入包，自动修正代码</td>
</tr>
<tr>
<td><code>Ctrl+Y</code></td>
<td>删除光标所在行</td>
</tr>
<tr>
<td><code>Ctrl+D</code></td>
<td>复制光标所在行的内容，插入光标位置下面</td>
</tr>
<tr>
<td>Ctrl+Alt+L</td>
<td>格式化代码</td>
</tr>
<tr>
<td><code>Ctrl+/</code></td>
<td>单行注释</td>
</tr>
<tr>
<td><code>Ctrl+Shift+/</code></td>
<td>选中代码注释，多行注释，再按取消注释</td>
</tr>
<tr>
<td><code>Alt+Ins</code></td>
<td>自动生成代码，toString，get，set等方法</td>
</tr>
<tr>
<td><code>Alt+Shift+上下箭头</code></td>
<td>移动当前代码行</td>
</tr>
</tbody></table>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><hr>
<h3 id="回顾–方法的定义和调用"><a href="#回顾–方法的定义和调用" class="headerlink" title="回顾–方法的定义和调用"></a>回顾–方法的定义和调用</h3><p>前面的课程中，使用过嵌套循环输出矩形，控制台打印出矩形就可以了，因此将方法定义为 <code>void</code> ，没有返回值。 在主方法 <code>main</code> 中直接被调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JAva"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Method_Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    	print();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++) &#123;<br>        		System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>        	&#125;<br>        	System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>print</code> 方法被 <code>main</code> 方法调用后直接输出结果，而 main 方法并不需要 <code>print</code> 方法的执行结果，所以被定义为 <code>void</code> 。</p>
<h3 id="定义方法的格式详解"><a href="#定义方法的格式详解" class="headerlink" title="定义方法的格式详解"></a>定义方法的格式详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数列表)&#123;<br>	<span class="hljs-comment">//代码省略...</span><br>	<span class="hljs-keyword">return</span> 结果;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>修饰符： <code>public static</code> 固定写法 </li>
<li>返回值类型： 表示方法运行的结果的数据类型，方法执行后将结果返回到调用者 </li>
<li>参数列表：方法在运算过程中的未知数据，调用者调用方法时传递 </li>
<li><code>return</code>：将方法执行后的结果带给调用者，方法执行到 <code>return</code> ，整体方法运行结束</li>
</ul>
<blockquote>
<p>小贴士：return <strong>结果</strong>; 这里的”结果”在开发中，我们正确的叫法成为<strong>方法的返回值</strong></p>
</blockquote>
<h3 id="定义方法的两个明确"><a href="#定义方法的两个明确" class="headerlink" title="定义方法的两个明确"></a>定义方法的两个明确</h3><ul>
<li><strong>需求</strong>：定义方法实现两个整数的求和计算。<ul>
<li><strong>明确返回值类型</strong>：方法计算的是整数的求和，结果也必然是个整数，返回值类型定义为int类型。</li>
<li><strong>明确参数列表</strong>：计算哪两个整数的和，并不清楚，但可以确定是整数，参数列表可以定义两个int类型的 变量，由调用者调用方法时传递</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Method_Demo2</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-comment">// 调用方法getSum，传递两个整数，这里传递的实际数据又称为实际参数</span><br>        <span class="hljs-comment">// 并接收方法计算后的结果，返回值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> getSum(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>        System.out.println(sum);<br>    &#125;<br>    <span class="hljs-comment">/*定义计算两个整数和的方法</span><br><span class="hljs-comment">    返回值类型，计算结果是int</span><br><span class="hljs-comment">    参数：不确定数据求和，定义int参数.参数又称为形式参数</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>程序执行，主方法 <code>main</code> 调用 <code>getSum</code> 方法，传递了实际数据 <code>5</code>和<code>6</code> ，两个变量 <code>a</code>和<code>b</code> 接收到的就是实际参数，并 将计算后的结果返回，主方法 <code>main</code> 中的变量 <code>sum</code> 接收的就是方法的返回值。</p>
<h3 id="调用方法的流程图解"><a href="#调用方法的流程图解" class="headerlink" title="调用方法的流程图解"></a>调用方法的流程图解</h3><p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>方法的三种调用格式</strong>：</p>
<ol>
<li><strong>单独调用</strong>：<code>方法名称(参数);</code></li>
<li><strong>打印调用</strong>： <code>System.out.println(方法名称(参数));</code></li>
<li><strong>赋值调用</strong>：<code>数据类型 变量名称 = 方法名称(参数);</code></li>
</ol>
</li>
<li><p><strong>注意</strong>：此前学习的方法,返回值类型固定写为 <code>void</code> ，这种方法只能单独调用,不能进行打印调用或者赋值调用。</p>
</li>
<li><p><strong>有参数</strong>：小括号当中有内容，当一个方法需要一些数据条件，才能完成任务的时候，就是有参数。</p>
<ul>
<li>例如俩个数字相加，必须知道俩个数字各自是多少，才能相加。</li>
</ul>
</li>
<li><p><strong>无参数</strong>：小括号当中无内容，一个方法不需要任何数据条件，自己就能独立完成任务，就是无参数。</p>
<ul>
<li>例如定义一个方法，打印固定10次HelloWorld。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E6%9C%89%E6%97%A0.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>注意事项</strong>：<ul>
<li>对于有返回值的方法，可以使用单独调用、打印调用或者赋值调用。</li>
<li>对于无返回值的方法，只能使用单独调用，不能使用打印调用或者赋值调用。</li>
</ul>
</li>
</ul>
<h3 id="方法的注意事项"><a href="#方法的注意事项" class="headerlink" title="方法的注意事项"></a>方法的注意事项</h3><ol>
<li>方法应该定义在类当中，但是不能在方法当中再定义方法。不能嵌套。</li>
<li>方法定义的前后顺序无所谓。</li>
<li>方法定义之后不会执行，如果希望执行，一定要调用：单独调用、打印调用、赋值调用。</li>
<li>如果方法有返回值，那么必须写上 <code>return 返回值</code> ，不能没有。</li>
<li><code>return</code>  后面的数据，必须和方法的返回值类型，对应起来</li>
<li>对于应该<code>void</code> 没有返回值的方法，不能写 <code>return</code> 后面的返回值，只能写 <code>return</code> 自己。</li>
<li>对于 <code>void</code> 方法当中最后一行的 <code>return</code> 可以省略不写。</li>
<li>一个方法当中可以有多个 <code>return</code> 语句，但是必须保证同时只有一个会被执行到，俩个 <code>return</code> 不能连写。</li>
</ol>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul>
<li><p>**方法重载(Overload)**：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返回值类型无关。 </p>
</li>
<li><p>参数列表：个数不同，数据类型不同，顺序不同。</p>
</li>
<li><p>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</p>
</li>
<li><p><strong>方法重载与下列因素相关</strong>：</p>
<ol>
<li>参数个数不同</li>
<li>参数类型不同</li>
<li>参数的多类型顺序不同</li>
</ol>
</li>
<li><p><strong>方法重载与下列因素无关</strong>：</p>
<ol>
<li>与参数的名称无关</li>
<li>与方法的返回值类型无关</li>
</ol>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组定义和访问"><a href="#数组定义和访问" class="headerlink" title="数组定义和访问"></a>数组定义和访问</h2><hr>
<h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><ul>
<li><strong>数组概念</strong>： 数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。</li>
<li><strong>数组的特点</strong>：<ol>
<li>数组是一种引用数据类型</li>
<li>数组当中的多个数据，类型必须统一</li>
<li>数组的长度在程序运行期间不可改变</li>
</ol>
</li>
</ul>
<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ul>
<li><p><strong>数组的初始化</strong>：在内存当中创建一个数组，并且向其他赋予一些默认值。</p>
</li>
<li><p><strong>俩种常见初始化方式</strong>：</p>
<ol>
<li>动态初始化（指定长度）：在创建数组的时候，直接指定数组当中的数据元素个数。</li>
<li>静态初始化（指定内容）：在创建数组的时候，不直接指定数据个数多少，而是直接将具体的数据内容进行指定。</li>
</ol>
</li>
<li><p><strong>动态初始化数组的格式</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名称 = <span class="hljs-keyword">new</span> 数据类型[数组长度];<br></code></pre></td></tr></table></figure>

<ul>
<li><p>数组定义格式详解： </p>
<ul>
<li>左边数据类型： 创建的数组容器可以存储什么数据类型。</li>
<li>[] : 表示数组。 </li>
<li>数组名字：为定义的数组起个变量名，满足标识符规范，可以使用名字操作数组。 </li>
<li><code>new</code>：关键字，创建数组使用的关键字。 </li>
<li>右边数据类型： 创建的数组容器可以存储什么数据类型，必须和左边的数据类型保持一致。 </li>
<li>[数组长度]：数组的长度，表示数组容器中可以存储多少个元素，是一个 <code>int</code> 数字。 </li>
<li><strong>注意：数组有定长特性，长度一旦指定，不可更改。</strong> <ul>
<li>和水杯道理相同，买了一个2升的水杯，总容量就是2升，不能多也不能少。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>静态初始化数组的格式</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名称 = <span class="hljs-keyword">new</span> 数据类型[] &#123;元素<span class="hljs-number">1</span>，元素<span class="hljs-number">2</span>，... &#125;;<span class="hljs-comment">//标准格式</span><br></code></pre></td></tr></table></figure>

<p>使用静态初始化数组的时候，格式还可以省略一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型[] 数组名称 = &#123;元素<span class="hljs-number">1</span>，元素<span class="hljs-number">2</span>，... &#125;;<span class="hljs-comment">//省略格式</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意事项：</p>
<ol>
<li>静态初始化没有直接指定长度，但是仍然会自动推算得到长度。</li>
<li>静态初始化标准格式可以拆分为俩个步骤。</li>
<li>动态初始化也可以拆分成为俩个步骤。</li>
<li>静态初始化一旦使用省略格式，就不能拆分成为俩个步骤了。</li>
</ol>
</li>
<li><p>使用建议：如果不确定数组当中的具体内容，用动态初始化；否则，已经确定了具体的内容，用静态初始化。</p>
</li>
</ul>
<h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><p>&#x3D;&#x3D;【注意】直接打印数组名称，得到的是数组对应的：内存哈希值。&#x3D;&#x3D;</p>
<ul>
<li><p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为**数组索引 (index)**，可以通过数组的索引访问到数组中的元素。</p>
</li>
<li><p><strong>索引值</strong>：就是一个 <code>int</code> 数字，代表数组当中元素的编号。</p>
<p>【注意】索引值从0开始，一直到“数组的长度-1”为止。</p>
</li>
<li><p><strong>格式</strong>：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据名[索引值]<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>数组的长度属性</strong>： 每个数组都具有长度，而且是固定的，Java中赋予了数组的一个属性，可以获取到数组的 长度，语句为： <code>数组名.length</code> ，属性<code>length</code>的执行结果是数组的长度，<code>int</code>类型结果。由次可以推断出，数 组的最大索引值为 <code>数组名.length-1</code> 。</p>
</li>
<li><p><strong>索引访问数组中的元素</strong>： </p>
<ul>
<li><code>数组名[索引]=数值</code>，为数组中的元素赋值 </li>
<li><code>变量=数组名[索引]</code>，获取出数组中的元素</li>
</ul>
</li>
<li><p>使用动态初始化数组的时候，其中的元素会自动拥有一个默认值。规则如下：</p>
<ul>
<li>如果是整数类型，那么默认为 <code>0</code>；</li>
<li>如果是浮点类型，那么默认为 <code>0.0</code>；</li>
<li>如果是字符类型，那么默认为 <code>\u0000</code>;</li>
<li>如果是布尔类型，那么默认为 <code>false</code>；</li>
<li>如果是引用类型，那么默认为 <code>null</code>。</li>
</ul>
</li>
</ul>
<p>&#x3D;&#x3D;【注意事项】静态初始化其实也有默认值的过程，只不过系统自动将默认值替换成为了大括号中的具体数值。&#x3D;&#x3D;</p>
<h2 id="数组原理内存图"><a href="#数组原理内存图" class="headerlink" title="数组原理内存图"></a>数组原理内存图</h2><hr>
<h3 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h3><p>内存是计算机中的重要原件，临时存储区域，作用是运行程序。我们编写的程序是存放在硬盘中的，在硬盘中的程 序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存。</p>
<p> Java虚拟机要运行程序，必须要对内存进行空间的分配和管理。</p>
<h3 id="Java虚拟机的内存划分"><a href="#Java虚拟机的内存划分" class="headerlink" title="Java虚拟机的内存划分"></a>Java虚拟机的内存划分</h3><p>为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。</p>
<ul>
<li><p>VM的内存划分：</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>寄存器</td>
<td>给CPU使用，和我们开发无关。</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>JVM在使用操作系统功能的时候使用，和我们开发无关</td>
</tr>
<tr>
<td>方法区</td>
<td>存储可以运行的class文件。</td>
</tr>
<tr>
<td>堆内存</td>
<td>存储对象或者数组，new来创建的，都存储在堆内存。</td>
</tr>
<tr>
<td>方法栈</td>
<td>方法运行时使用的内存，比如main方法运行，进入方法栈中执行。</td>
</tr>
</tbody></table>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/Java%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="数组在内存中的存储"><a href="#数组在内存中的存储" class="headerlink" title="数组在内存中的存储"></a>数组在内存中的存储</h3><p><strong>一个数组的内存图</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>	<span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>	System.out.println(arr);<span class="hljs-comment">//[I@5f150435</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上方法执行，输出结果是 &#x3D;&#x3D;[I@5f150435&#x3D;&#x3D; ，这是个什么呢？是数组在内存中的地址。<code>new</code> 出来的内容，都是在堆内存中存储的，而方法中的<code>变量arr</code> 保存的数组的地址。</p>
<p><strong>输出 <code>arr[0]</code> ，就会输出 <code>arr</code> 保存的内存地址中数组中0索引上的元素</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>两个数组内存图</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>	<span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>	<span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>	System.out.println(arr);<br>	System.out.println(arr2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>两个变量指向一个数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 定义数组，存储3个元素</span><br>    <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>    <span class="hljs-comment">//数组索引进行赋值</span><br>    arr[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;<br>    arr[<span class="hljs-number">1</span>] = <span class="hljs-number">6</span>;<br>    arr[<span class="hljs-number">2</span>] = <span class="hljs-number">7</span>;<br>    <span class="hljs-comment">//输出3个索引上的元素值</span><br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    System.out.println(arr[<span class="hljs-number">1</span>]);<br>    System.out.println(arr[<span class="hljs-number">2</span>]);<br>    <span class="hljs-comment">//定义数组变量arr2，将arr的地址赋值给arr2</span><br>    <span class="hljs-type">int</span>[] arr2 = arr;<br>    arr2[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span>;<br>    System.out.println(arr[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E6%8C%87%E5%90%91%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h2><hr>
<h3 id="数组越界异常"><a href="#数组越界异常" class="headerlink" title="数组越界异常"></a>数组越界异常</h3><p>观察一下代码，运行后会出现什么结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    System.out.println(arr[<span class="hljs-number">3</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建数组，赋值3个元素，数组的索引就是0，1，2，没有3索引，因此我们不能访问数组中不存在的索引，程序运行后，将会抛出 <code>ArrayIndexOutOfBoundsException</code> 数组越界异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%B8%8B%E6%A0%87%E8%B6%8A%E7%95%8C%E5%BC%82%E5%B8%B8.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="数组空指针异常"><a href="#数组空指针异常" class="headerlink" title="数组空指针异常"></a>数组空指针异常</h3><p>观察一下代码，运行后会出现什么结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    arr = <span class="hljs-literal">null</span>;<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>｝<br></code></pre></td></tr></table></figure>

<p><code>arr = null</code> 这行代码，意味着变量arr将不会在保存数组的内存地址，也就不允许再操作数组了，因此运行的时候会抛出 <code>NullPointerException</code> 空指针异常。在开发中，数组的越界异常是不能出现的，一旦出现了，就必须要修改我们编写的代码。</p>
<p>解决：补上new</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8.png" srcset="/img/loading.gif" lazyload></p>
<p><strong>空指针异常在内存图中的表现</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="数组遍历【重点】"><a href="#数组遍历【重点】" class="headerlink" title="数组遍历【重点】"></a>数组遍历【重点】</h3><ul>
<li><strong>数组遍历 ：</strong>就是将数组中的每个元素分别获取出来，就是遍历。遍历也是数组操作中的基石。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    System.out.println(arr[<span class="hljs-number">1</span>]);<br>    System.out.println(arr[<span class="hljs-number">2</span>]);<br>    System.out.println(arr[<span class="hljs-number">3</span>]);<br>    System.out.println(arr[<span class="hljs-number">4</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上代码是可以将数组中每个元素全部遍历出来，但是如果数组元素非常多，这种写法肯定不行，因此我们需要改造成循环的写法。数组的索引是<code>0</code> 到 <code>lenght-1</code> ，可以作为循环的条件出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        System.out.println(arr[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组获取最大值元素"><a href="#数组获取最大值元素" class="headerlink" title="数组获取最大值元素"></a>数组获取最大值元素</h3><ul>
<li>最大值获取：从数组的所有元素中找出最大值。、</li>
<li>实现思路：<ul>
<li>定义变量，保存数组0索引上的元素</li>
<li>遍历数组，获取出数组中的每个元素</li>
<li>将遍历到的元素和保存数组0索引上值的变量进行比较</li>
<li>如果数组元素的值大于了变量的值，变量记录住新的值</li>
<li>数组循环遍历结束，变量保存的就是数组中的最大值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">100</span>, <span class="hljs-number">4000</span> &#125;;<br>    <span class="hljs-comment">//定义变量，保存数组中0索引的元素</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//遍历数组，取出每个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-comment">//遍历到的元素和变量max比较</span><br>        <span class="hljs-comment">//如果数组元素大于max</span><br>        <span class="hljs-keyword">if</span> (arr[i] &gt; max) &#123;<br>            <span class="hljs-comment">//max记录住大值</span><br>            max = arr[i];<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;数组最大值是： &quot;</span> + max);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h3><ul>
<li>数组的反转： 数组中的元素颠倒顺序，例如原始数组为1,2,3,4,5，反转后的数组为5,4,3,2,1</li>
<li>实现思想：数组最远端的元素互换位置。<ul>
<li>实现反转，就需要将数组最远端元素位置交换</li>
<li>定义两个变量，保存数组的最小索引和最大索引</li>
<li>两个索引上的元素交换位置</li>
<li>最小索引++，最大索引–，再次交换位置</li>
<li>最小索引超过了最大索引，数组反转操作结束</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%95%B0%E7%BB%84%E5%8F%8D%E8%BD%AC.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	循环中定义变量min=0最小索引</span><br><span class="hljs-comment">    	max=arr.length‐1最大索引</span><br><span class="hljs-comment">    	min++,max‐‐</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = arr.length ‐ <span class="hljs-number">1</span>; min &lt;= max; min++, max‐‐) &#123;<br>        <span class="hljs-comment">//利用第三方变量完成数组中的元素交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[min];<br>        arr[min] = arr[max];<br>        arr[max] = temp;<br>    &#125;<br>    <span class="hljs-comment">// 反转后，遍历数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    	System.out.println(arr[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="数组作为方法参数和返回值"><a href="#数组作为方法参数和返回值" class="headerlink" title="数组作为方法参数和返回值"></a>数组作为方法参数和返回值</h2><hr>
<h3 id="数组作为方法参数"><a href="#数组作为方法参数" class="headerlink" title="数组作为方法参数"></a>数组作为方法参数</h3><p>以前的方法中我们学习了方法的参数和返回值，但是使用的都是基本数据类型。那么作为引用类型的数组能否作为方法的参数进行传递呢，当然是可以的。</p>
<ul>
<li>数组作为方法参数传递，传递的参数是数组内存的地址。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span> &#125;;<br>	<span class="hljs-comment">//调用方法，传递数组</span><br>	printArray(arr);<br>&#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	创建方法，方法接收数组类型的参数</span><br><span class="hljs-comment">    	进行数组的遍历</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    	System.out.println(arr[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="数组作为方法返回值"><a href="#数组作为方法返回值" class="headerlink" title="数组作为方法返回值"></a>数组作为方法返回值</h3><ul>
<li>数组作为方法的返回值，返回的数组的内存地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//调用方法，接收数组的返回值</span><br>    <span class="hljs-comment">//接收到的是数组的内存地址</span><br>    <span class="hljs-type">int</span>[] arr = getArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    	System.out.println(arr[i]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建方法，返回值是数组类型</span><br><span class="hljs-comment">    return返回数组的地址</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getArray() &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span> &#125;;<br>    <span class="hljs-comment">//返回数组的地址，返回到调用者</span><br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="方法的参数类型区别"><a href="#方法的参数类型区别" class="headerlink" title="方法的参数类型区别"></a>方法的参数类型区别</h3><p><strong>代码分析</strong></p>
<p><strong>1.分析下列程序代码，计算输出结果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    System.out.println(a);<br>    System.out.println(b);<br>    change(a, b);<br>    System.out.println(a);<br>    System.out.println(b);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    a = a + b;<br>    b = b + a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2. 分析下列程序代码，计算输出结果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>    change(arr);<br>    System.out.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>	arr[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>总结：</p>
<p><strong>方法的参数为基本类型时,传递的是数据值. 方法的参数为引用类型时,传递的是地址值。</strong></p>
</blockquote>
<h1 id="类与对象、封装、构造方法"><a href="#类与对象、封装、构造方法" class="headerlink" title="类与对象、封装、构造方法"></a>类与对象、封装、构造方法</h1><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><hr>
<h3 id="面向对象思想概述"><a href="#面向对象思想概述" class="headerlink" title="面向对象思想概述"></a>面向对象思想概述</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>Java语言是一种面向对象的程序设计语言，而面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>洗衣服：</p>
<ul>
<li>面向过程：把衣服脱下来–&gt;找一个盆–&gt;放点洗衣粉–&gt;加点水–&gt;浸泡10分钟–&gt;揉一揉–&gt;清洗衣服–&gt;拧干–&gt;晾起来</li>
<li>面向对象：把衣服脱下来–&gt;打开全自动洗衣机–&gt;扔衣服–&gt;按钮–&gt;晾起来</li>
</ul>
<p>区别:</p>
<ul>
<li>面向过程：强调步骤。</li>
<li>面向对象：强调对象，这里的对象就是洗衣机。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成了指挥者。面向对象的语言中，包含了三大基本特征，即封装、继承和多态。</p>
<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><p>环顾周围，你会发现很多对象，比如桌子，椅子，同学，老师等。桌椅属于办公用品，师生都是人类。那么什么是类呢？什么是对象呢？</p>
<h4 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h4><ul>
<li><strong>类：</strong>是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</li>
</ul>
<p>现实中，描述一类事物：</p>
<ul>
<li>属性：就是该事物的状态信息。</li>
<li>行为：就是该事物能够做什么。</li>
</ul>
<p>举例：小猫。</p>
<p>属性：名字、体重、年龄、颜色。 行为：走、跑、叫。</p>
<h4 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h4><ul>
<li><strong>对象：</strong>是一类事物的具体体现。对象是类的一个<strong>实例</strong>（对象并不是找个女朋友），必然具备该类事物的属性和行为。</li>
</ul>
<p>现实中，一类事物的一个实例：一只小猫。</p>
<p>举例：一只小猫。</p>
<p>属性：tom、5kg、2 years、yellow。 行为：溜墙根走、蹦跶的跑、喵喵叫。</p>
<h4 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h4><ul>
<li>类是对一类事物的描述，是<strong>抽象的。</strong></li>
<li>对象是一类事物的实例，是<strong>具体的。</strong></li>
<li><strong>类是对象的模板，对象是类的实体。</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h3><h4 id="事物与类的对比"><a href="#事物与类的对比" class="headerlink" title="事物与类的对比"></a>事物与类的对比</h4><p>现实世界的一类事物：</p>
<ul>
<li><strong>属性</strong>：事物的状态信息。</li>
<li><strong>行为</strong>：事物能够做什么。</li>
</ul>
<p>Java中用<code>class</code> 描述事物也是如此：</p>
<ul>
<li><strong>成员变量</strong>：对应事物的<strong>属性</strong></li>
<li><strong>成员方法</strong>：对应事物的<strong>行为</strong></li>
</ul>
<h4 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br>	<span class="hljs-comment">//成员变量</span><br>    <span class="hljs-comment">//成员方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>定义类</strong>：就是定义类的成员，包括<strong>成员变量</strong>和<strong>成员方法</strong>。</li>
<li><strong>成员变量</strong>：和以前定义变量几乎是一样的。只不过位置发生了改变。<strong>在类中，方法外</strong>。</li>
<li><strong>成员方法</strong>：和以前定义方法几乎是一样的。只不过<strong>把<code>static</code>去掉</strong>，<code>static</code>的作用在面向对象后面课程中再详细讲解。</li>
</ul>
<p><strong>【注意事项】</strong></p>
<ol>
<li>成员变量是直接定义在类当中的，在方法外边。</li>
<li>成员变量不要写<code>static</code>关键字。</li>
</ol>
<h3 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h3><h4 id="对象的使用格式"><a href="#对象的使用格式" class="headerlink" title="对象的使用格式"></a>对象的使用格式</h4><p>创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">类名 对象名 = <span class="hljs-keyword">new</span> 类名();<br></code></pre></td></tr></table></figure>

<p>使用对象访问类中的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">对象名.成员变量；<br>对象名.成员方法()；<br></code></pre></td></tr></table></figure>

<h4 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h4><p>如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样，如下表。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>数据类型</strong></th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>整数（<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>）</td>
<td><code>0</code></td>
</tr>
<tr>
<td></td>
<td>浮点数（<code>float</code>，<code>double</code>）</td>
<td><code>0.0</code></td>
</tr>
<tr>
<td></td>
<td>字符（<code>char</code>）</td>
<td><code>&#39;\u0000&#39;</code></td>
</tr>
<tr>
<td></td>
<td>布尔（<code>boolean</code>）</td>
<td><code>false</code></td>
</tr>
<tr>
<td>引用类型</td>
<td>数组，类，接口，字符串（<code>Stirng</code>）</td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h3 id="对象内存图"><a href="#对象内存图" class="headerlink" title="对象内存图"></a>对象内存图</h3><h4 id="一个对象，调用一个方法内存图"><a href="#一个对象，调用一个方法内存图" class="headerlink" title="一个对象，调用一个方法内存图"></a>一个对象，调用一个方法内存图</h4><p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>通过上图，我们可以理解，在栈内存中运行的方法，遵循”先进后出，后进先出”的原则。变量p指向堆内存中的空间，寻找方法信息，去执行该方法。</p>
<p>但是，这里依然有问题存在。创建多个对象时，如果每个对象内部都保存一份方法信息，这就非常浪费内存了，因为所有对象的方法信息都是一样的。那么如何解决这个问题呢？请看如下图解。</p>
</blockquote>
<h4 id="两个对象，调用一个方法内存图"><a href="#两个对象，调用一个方法内存图" class="headerlink" title="两个对象，调用一个方法内存图"></a>两个对象，调用一个方法内存图</h4><p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>对象调用方法是，根据对象中的方法标记（地址值），去类中寻找方法信息。这样哪怕是多个对象，方法信息只保存一份，节约内存空间。</p>
</blockquote>
<h4 id="一个引用，作为参数传递到方法中内存图"><a href="#一个引用，作为参数传递到方法中内存图" class="headerlink" title="一个引用，作为参数传递到方法中内存图"></a>一个引用，作为参数传递到方法中内存图</h4><p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0%E6%96%B9%E6%B3%95%E4%B8%AD%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>引用类型作为参数，传递的是地址值。</p>
</blockquote>
<h3 id="成员变量和局部变量区别"><a href="#成员变量和局部变量区别" class="headerlink" title="成员变量和局部变量区别"></a>成员变量和局部变量区别</h3><p>变量根据定义<strong>位置的不同</strong>，给变量起了不同的名字。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%8C%BA%E5%88%AB.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>在类中的位置不同 &#x3D;&#x3D;【重点】&#x3D;&#x3D;<ul>
<li>成员变量：类中,方法外</li>
<li>局部变量：方法中或者方法声明上(形式参数)</li>
</ul>
</li>
<li>作用范围不一样 &#x3D;&#x3D;【重点】&#x3D;&#x3D;<ul>
<li>成员变量：类中</li>
<li>局部变量：方法中</li>
</ul>
</li>
<li>初始化值的不同 &#x3D;&#x3D;【重点】&#x3D;&#x3D;<ul>
<li>成员变量：有默认值</li>
<li>局部变量：没有默认值。必须先定义，赋值，最后使用</li>
</ul>
</li>
<li>在内存中的位置不同 <ul>
<li>成员变量：堆内存</li>
<li>局部变量：栈内存</li>
</ul>
</li>
<li>生命周期不同<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
</ul>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><hr>
<h3 id="封装概述"><a href="#封装概述" class="headerlink" title="封装概述"></a>封装概述</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性</p>
<h4 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h4><p>将<strong>属性隐藏</strong>起来,若需要访问某个属性，<strong>提供公共方法</strong>对其访问。</p>
<h3 id="封装的步骤"><a href="#封装的步骤" class="headerlink" title="封装的步骤"></a>封装的步骤</h3><ol>
<li>使用 <code>private</code> 关键自来修饰成员变量。</li>
<li>对需要访问的成员变量，提供对应的一对 <code>getXxx</code> 方法、<code>setXxx</code> 方法。</li>
</ol>
<h3 id="封装的操作——-private-关键字"><a href="#封装的操作——-private-关键字" class="headerlink" title="封装的操作—— private 关键字"></a>封装的操作—— <code>private</code> 关键字</h3><hr>
<h4 id="private的含义"><a href="#private的含义" class="headerlink" title="private的含义"></a><code>private</code>的含义</h4><ol>
<li><code>private</code> 是一个权限修饰符，代表最小权限。</li>
<li>可以修饰成员变量和成员方法。</li>
<li>被 <code>private</code> 修饰后的成员变量和成员方法，只在本类中才能访问。</li>
</ol>
<h4 id="private的使用格式"><a href="#private的使用格式" class="headerlink" title="private的使用格式"></a><code>private</code>的使用格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> 数据类型 变量名 ;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>使用 <code>private</code> 修饰成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>提供 <code>getXxx</code> 方法 &#x2F; <code>setXxx</code> 方法，可以访问成员变量，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String n)</span> &#123;<br>    	name = n;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    	age = a;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="封装优化1——this关键字"><a href="#封装优化1——this关键字" class="headerlink" title="封装优化1——this关键字"></a>封装优化1——<code>this</code>关键字</h3><hr>
<p>我们发现 <code>setXxx</code> 方法中的形参名字并不符合见名知意的规定，那么如果修改与成员变量名一致，是否就见名知意了呢？代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>    	age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过修改和测试，我们发现新的问题，成员变量赋值失败了。也就是说，在修改了<code>setXxx()</code> 的形参变量名后，方法并没有给成员变量赋值！这是由于形参变量名与成员变量名重名，导致成员变量名被隐藏，方法中的变量名，无法访问到成员变量，从而赋值失败。所以，我们只能使用this关键字，来解决这个重名问题。</p>
<h4 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a><code>this</code>的含义</h4><p><code>this</code> 代表所在类的当前对象的引用（地址值），即对象自己的引用。</p>
<blockquote>
<p>记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</p>
</blockquote>
<h4 id="this使用格式"><a href="#this使用格式" class="headerlink" title="this使用格式"></a><code>this</code>使用格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.成员变量名<br></code></pre></td></tr></table></figure>

<p>使用 <code>this</code> 修饰方法中的变量，解决成员变量被隐藏的问题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-comment">//name = name;</span><br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-comment">//age = age;</span><br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：方法中只有一个变量名时，默认也是使用 <code>this</code> 修饰，可以省略不写。</p>
</blockquote>
<h3 id="封装优化2——构造方法"><a href="#封装优化2——构造方法" class="headerlink" title="封装优化2——构造方法"></a>封装优化2——构造方法</h3><p>当一个对象被创建时候，构造方法用来初始化该对象，给对象的成员<strong>变量赋初始值</strong>。</p>
<blockquote>
<p>小贴士：无论你与否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个无参数构造方法，<br>一旦自己定义了构造方法，Java自动提供的默认无参数构造方法就会失效。</p>
</blockquote>
<h4 id="构造方法的定义格式"><a href="#构造方法的定义格式" class="headerlink" title="构造方法的定义格式"></a>构造方法的定义格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 构造方法名(参数列表)&#123;<br>	<span class="hljs-comment">// 方法体</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>构造方法的写法上，方法名与它所在的类名相同。它没有返回值，所以不需要返回值类型，甚至不需要void。使用<br>构造方法后，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// 无参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125;<br><br>    <span class="hljs-comment">// 有参数构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>【注意事项】</strong></p>
<ol>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果没有编写任何构造方法，那么编译器将会默认赠送一个构造方法，没有参数、方法体什么事情都不做。<br>public Student() {}</li>
<li>一旦编写了至少一个构造方法，那么编译器将不再赠送。</li>
<li>构造方法也是可以进行重载的。<br>重载：方法名称相同，参数列表不同。</li>
</ol>
<h4 id="标准代码——JavaBean"><a href="#标准代码——JavaBean" class="headerlink" title="标准代码——JavaBean"></a>标准代码——JavaBean</h4><p><code>JavaBean</code> 是 Java语言编写类的一种标准规范。符合<code>JavaBean</code> 的类，要求类必须是具体的和公共的，并且具有无参数的构造方法，提供用来操作成员变量的<code>set</code> 和<code>get</code> 方法。</p>
<p>一个标准的类通常要拥有下面四个组成部分：</p>
<ol>
<li>所有的成员变量都要使用<code>private</code>关键字修饰</li>
<li>为每一个成员变量编写一对儿<code>Getter/Setter</code>方法</li>
<li>编写一个无参数的构造方法</li>
<li>编写一个全参数的构造方法</li>
</ol>
<p>这样标准的类也叫做<code>JavaBean</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-comment">//无参构造方法【必须】</span><br>    <span class="hljs-comment">//有参构造方法【建议】</span><br>    <span class="hljs-comment">//成员方法</span><br>    <span class="hljs-comment">//getXxx()</span><br>    <span class="hljs-comment">//setXxx()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写符合<code>JavaBean</code> 规范的类，以学生类为例，标准代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-comment">//成员变量</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">//构造方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;&#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(String name,<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-comment">//成员方法</span><br>    publicvoid <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>   		<span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    publicvoid <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>    	<span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    publicint <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>    	<span class="hljs-keyword">return</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStudent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//无参构造使用</span><br>        Student s= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        s.setName(<span class="hljs-string">&quot;柳岩&quot;</span>);<br>        s.setAge(<span class="hljs-number">18</span>);<br>        System.out.println(s.getName()+<span class="hljs-string">&quot;‐‐‐&quot;</span>+s.getAge());<br>        <span class="hljs-comment">//带参构造使用</span><br>        Student s2= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;赵丽颖&quot;</span>,<span class="hljs-number">18</span>);<br>        System.out.println(s2.getName()+<span class="hljs-string">&quot;‐‐‐&quot;</span>+s2.getAge());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><hr>
<h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>API(Application Programming Interface)，应用程序编程接口。Java API是一本程序员的字典 ，是JDK中提供给我们使用的类的说明文档。这些类将底层的代码实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可。所以我们可以通过查询API的方式，来学习Java提供的类，并得知如何使用它们。</p>
<h3 id="API使用步骤"><a href="#API使用步骤" class="headerlink" title="API使用步骤"></a>API使用步骤</h3><ol>
<li>打开帮助文档。</li>
<li>点击显示，找到索引，看到输入框。</li>
<li>你要找谁？在输入框里输入，然后回车。</li>
<li>看包。java.lang下的类不需要导包，其他需要。</li>
<li>类的解释和说明。</li>
<li>学习构造方法。</li>
<li>使用成员方法。</li>
</ol>
<h2 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a><code>Scanner</code>类</h2><hr>
<p>了解了API的使用方式，我们通过Scanner类，熟悉一下查询API，并使用类的步骤。</p>
<h3 id="什么是Scanner类"><a href="#什么是Scanner类" class="headerlink" title="什么是Scanner类"></a>什么是<code>Scanner</code>类</h3><p>一个可以解析基本类型和字符串的简单文本扫描器。 例如，以下代码使用户能够从 System.in 中读取一个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.nextInt();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>备注：<code>System.in</code>  系统输入指的是通过键盘录入数据。</p>
</blockquote>
<h3 id="引用类型使用步骤"><a href="#引用类型使用步骤" class="headerlink" title="引用类型使用步骤"></a>引用类型使用步骤</h3><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>使用 <code>import</code> 关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。 格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> 包名.类名;<br></code></pre></td></tr></table></figure>

<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>使用该类的构造方法，创建一个该类的对象。格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">数据类型 变量名 = <span class="hljs-keyword">new</span> 数据类型(参数列表);<br></code></pre></td></tr></table></figure>

<h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><p>调用该类的成员方法，完成指定功能。格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">变量名.方法名();<br></code></pre></td></tr></table></figure>

<h3 id="Scanner使用步骤"><a href="#Scanner使用步骤" class="headerlink" title="Scanner使用步骤"></a><code>Scanner</code>使用步骤</h3><h4 id="查看类"><a href="#查看类" class="headerlink" title="查看类"></a>查看类</h4><ul>
<li><code>java.util.Scanner</code> ：该类需要 <code>import</code> 导入后使用。</li>
</ul>
<h4 id="查看构造方法"><a href="#查看构造方法" class="headerlink" title="查看构造方法"></a>查看构造方法</h4><ul>
<li><code>public Scanner(InputStream source)</code> ：构造一个新的 <code>Scanner</code>，它生成的值是从指定的输入流扫描的。</li>
</ul>
<h4 id="查看成员方法"><a href="#查看成员方法" class="headerlink" title="查看成员方法"></a>查看成员方法</h4><ul>
<li><code>public int nextInt()</code>：将输入信息的下一个标记扫描为一个 <code>int</code> 值。</li>
</ul>
<p>使用 <code>Scanner</code> 类，完成接收键盘录入数据的操作，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.导包</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01_Scanner</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//2.创建键盘录入数据的对象</span><br>     	<span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <br>        <span class="hljs-comment">//3.接收数据</span><br>        System.out.println(<span class="hljs-string">&quot;请录入一个整数：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> sc.naxtInt();<br>        <br>        <span class="hljs-comment">//4.输出数据</span><br>        System.out.println(<span class="hljs-string">&quot;i:&quot;</span> + i);<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。虽然是创建对象的简化写法，但是应用<br>场景非常有限。</p>
<ul>
<li><strong>匿名对象</strong>：没有变量名的对象。</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 类名(参数列表);<br></code></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br></code></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li><p>创建匿名对象直接调用方法，没有变量名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).nextInt();<br></code></pre></td></tr></table></figure>
</li>
<li><p>一旦调用俩次打打，就是创建了俩个对象，造成浪费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).nextInt();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).nextInt();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。</p>
<p>使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。</p>
</blockquote>
</li>
<li><p>匿名对象可以作为方法的参数和返回值</p>
</li>
</ol>
<ul>
<li><p>作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 普通方式</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        input(sc);<br>        <span class="hljs-comment">//匿名对象作为方法接收的参数</span><br>        input(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in));<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">input</span><span class="hljs-params">(Scanner sc)</span>&#123;<br>    	System.out.println(sc);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>作为返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 普通方式</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> getScanner();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Scanner <span class="hljs-title function_">getScanner</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//普通方式</span><br>        <span class="hljs-comment">//Scanner sc = new Scanner(System.in);</span><br>        <span class="hljs-comment">//return sc;</span><br>        <span class="hljs-comment">//匿名对象作为方法返回值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Random类"><a href="#Random类" class="headerlink" title="Random类"></a>Random类</h2><hr>
<h3 id="什么是Random类"><a href="#什么是Random类" class="headerlink" title="什么是Random类"></a>什么是Random类</h3><p>此类的实例用于生成伪随机数。</p>
<p>例如，以下代码使用户能够得到一个随机数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> r.nextInt();<br></code></pre></td></tr></table></figure>

<h3 id="Random使用步骤"><a href="#Random使用步骤" class="headerlink" title="Random使用步骤"></a>Random使用步骤</h3><h4 id="查看类-1"><a href="#查看类-1" class="headerlink" title="查看类"></a>查看类</h4><ul>
<li><code>java.util.Random</code>：该类需要<code>import</code>导入后使用。</li>
</ul>
<h4 id="查看构造方法-1"><a href="#查看构造方法-1" class="headerlink" title="查看构造方法"></a>查看构造方法</h4><ul>
<li><code>public Random()</code>：创建一个新的随机数生成器。</li>
</ul>
<h4 id="查看成员方法-1"><a href="#查看成员方法-1" class="headerlink" title="查看成员方法"></a>查看成员方法</h4><ul>
<li><code>public int nextInt(int n)</code>：返回一个伪随机数，范围在<code>0</code>包括）和<code>指定值n</code>（不包括）之间的<code>int</code>值。</li>
</ul>
<blockquote>
<p>备注：创建一个<code>Random</code>对象，每次调用<code>nextInt()</code>方法，都会生成一个随机数。</p>
</blockquote>
<h2 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h2><hr>
<h3 id="什么是ArrayList类"><a href="#什么是ArrayList类" class="headerlink" title="什么是ArrayList类"></a>什么是ArrayList类</h3><p><code>java.util.ArrayList</code>是大小<strong>可变的数组</strong>的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 <code>ArrayList</code>中可不断添加元素，其大小也自动增长。</p>
<h3 id="ArrayList使用步骤"><a href="#ArrayList使用步骤" class="headerlink" title="ArrayList使用步骤"></a>ArrayList使用步骤</h3><h4 id="查看类-2"><a href="#查看类-2" class="headerlink" title="查看类"></a>查看类</h4><ul>
<li><code>java.util.ArrayList&lt;E&gt;</code>：构造一个内容为空的集合。</li>
</ul>
<p>基本格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arraylist</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure>

<p>在JDK 7后,右侧泛型的尖括号之内可以留空，但是&lt;&gt;仍然要写。简化格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Arraylist</span>&lt;();<br></code></pre></td></tr></table></figure>

<h4 id="查看成员方法-2"><a href="#查看成员方法-2" class="headerlink" title="查看成员方法"></a>查看成员方法</h4><ul>
<li><p><code>public boolean add(E e)</code> ： 将指定的元素添加到此集合的尾部。</p>
<p>参数<code>E e</code>，在构造ArrayList对象时， <code>&lt;E&gt;</code>指定了什么数据类型，那么<code>add(E e)</code>方法中，只能添加什么数据类型的对象。</p>
</li>
</ul>
<h3 id="常用方法和遍历"><a href="#常用方法和遍历" class="headerlink" title="常用方法和遍历"></a>常用方法和遍历</h3><p>对于元素的操作,基本体现在——增、删、查。常用的方法有：</p>
<ul>
<li><code>public boolean add(E e)</code>：将指定的元素添加到此集合的尾部。</li>
<li><code>public E remove(int index)</code>：移除此集合中指定位置上的元素。返回被删除的元素。</li>
<li><code>public E get(int index)</code> ：返回此集合中指定位置上的元素。返回获取的元素。</li>
<li><code>public int size()</code>：返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01ArrayListMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建集合对象</span><br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <br>        <span class="hljs-comment">//添加元素</span><br>        list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;world&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;java&quot;</span>);<br>        <br>        <span class="hljs-comment">//public E get(int index):返回指定索引处的元素</span><br>        System.out.println(<span class="hljs-string">&quot;get:&quot;</span>+list.get(<span class="hljs-number">0</span>));<br>        System.out.println(<span class="hljs-string">&quot;get:&quot;</span>+list.get(<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;get:&quot;</span>+list.get(<span class="hljs-number">2</span>));<br>        <br>        <span class="hljs-comment">//public int size():返回集合中的元素的个数</span><br>        System.out.println(<span class="hljs-string">&quot;size:&quot;</span>+list.size());<br>        <br>        <span class="hljs-comment">//public E remove(int index):删除指定索引处的元素，返回被删除的元素</span><br>        System.out.println(<span class="hljs-string">&quot;remove:&quot;</span>+list.remove(<span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-comment">//遍历输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++)&#123;<br>            System.out.println(list.get(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何存储基本数据类型"><a href="#如何存储基本数据类型" class="headerlink" title="如何存储基本数据类型"></a>如何存储基本数据类型</h3><p>ArrayList对象不能存储基本类型，只能存储引用类型的数据。类似 <code>&lt;int&gt;</code> <strong>不能写</strong>，但是存储基本数据类型对应的包装类型是可以的。所以，想要存储基本类型数据， <code>&lt;&gt;</code> 中的数据类型，必须转换后才能编写，转换写法如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>基本类型包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p>我们发现，只有 <code>Integer</code> 和 <code>Character</code> 需要特殊记忆，其他基本类型只是首字母大写即可。那么存储基本类型数据，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02ArrayListMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        list.add(<span class="hljs-number">1</span>);<br>        list.add(<span class="hljs-number">2</span>);<br>        list.add(<span class="hljs-number">3</span>);<br>        list.add(<span class="hljs-number">4</span>);<br>        <br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><hr>
<h3 id="String类概述"><a href="#String类概述" class="headerlink" title="String类概述"></a>String类概述</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p><code>java.lang.String</code> 类代表字符串。Java程序中所有的字符串文字（例如 <code>&quot;abc&quot;</code> ）都可以别看作是实现此类的实例.</p>
<p>类 <code>String</code> 中包括用于检查个字符串的方法，比如用于<strong>比较</strong>字符串，<strong>搜素</strong>字符串，<strong>提取</strong>子字符串以及创建具有翻译为<strong>大写</strong>或<strong>小写</strong>的所有字符的字符串副本。</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>字符串不变 ：字符串的值在创建后不能被更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>s1 += <span class="hljs-string">&quot;d&quot;</span>;<br>System.out.println(s1);<span class="hljs-comment">//&quot;abcd&quot;</span><br><span class="hljs-comment">//内存中有&quot;abc&quot;，&quot;abcd&quot;俩个对象，s1从指向&quot;abc&quot;，改变指向，指向了&quot;abcd&quot;。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>因为String对象是不可变的，所以它们可以被共享。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-comment">//内存中只有一个&quot;abc&quot;对象被创建，同时被s1和s2共享</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>&quot;abc&quot;</code>等效于<code>char[] data=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">例如：<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>相当于：<br><span class="hljs-type">char</span>[] data = &#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data);<br><span class="hljs-comment">//String底层是靠字符数组实现的。</span><br></code></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="查看类-3"><a href="#查看类-3" class="headerlink" title="查看类"></a>查看类</h4><ul>
<li><code>java.langString</code>：此类不需要导入。</li>
</ul>
<h4 id="查看构造方法-2"><a href="#查看构造方法-2" class="headerlink" title="查看构造方法"></a>查看构造方法</h4><ul>
<li><p><code>public String()</code> ：初始化新创建的String对象，以使其表示空字符序列。</p>
</li>
<li><p><code>public String(char[] value)</code> ：通过当前参数中的字符数组来构造新的String。</p>
</li>
<li><p><code>public String(byte[] bytes)</code> ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。</p>
</li>
<li><p>构造举例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br><br><span class="hljs-comment">// 通过字符数组构造</span><br><span class="hljs-type">char</span> chars[] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(chars);<br><br><span class="hljs-comment">// 通过字节数组构造</span><br><span class="hljs-type">byte</span> bytes[] = &#123; <span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span> &#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="判断功能的方法"><a href="#判断功能的方法" class="headerlink" title="判断功能的方法"></a>判断功能的方法</h4><ul>
<li><p><code>public boolean equals(Object anObject)</code> ：将此字符与指定对象进行比较。</p>
</li>
<li><p><code>public Boolean equalsIgnoreCase(String anotherString)</code> ：将此字符与指定对象进行比较，忽略大小写。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String_Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建字符串对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HELLO&quot;</span>;<br>        <br>        <span class="hljs-comment">// boolean equals(Object obj):比较字符串的内容是否相同</span><br>        System.out.println(s1.equals(s2)); <span class="hljs-comment">// true</span><br>        System.out.println(s1.equals(s3)); <span class="hljs-comment">// false</span><br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">//boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写</span><br>        System.out.println(s1.equalsIgnoreCase(s2)); <span class="hljs-comment">// true</span><br>        System.out.println(s1.equalsIgnoreCase(s3)); <span class="hljs-comment">// true</span><br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。</p>
</blockquote>
<h4 id="获取功能的方法"><a href="#获取功能的方法" class="headerlink" title="获取功能的方法"></a>获取功能的方法</h4><ul>
<li><code>public int length ()</code> ：返回此字符串的长度。</li>
<li><code>public String concat (String str)</code> ：将指定的字符串连接到该字符串的末尾。</li>
<li><code>public char charAt (int index)</code> ：返回指定索引处的 char值。</li>
<li><code>public int indexOf (String str)</code> ：返回指定子字符串第一次出现在该字符串内的索引。</li>
<li><code>public String substring (int beginIndex)</code> ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。</li>
<li><code>public String substring (int beginIndex, int endIndex)</code> ：返回一个子字符串，从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String_Demo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建字符串对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld&quot;</span>;<br>        <br>        <span class="hljs-comment">// int length():获取字符串的长度，其实也就是字符个数</span><br>        System.out.println(s.length());<br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">// String concat (String str):将将指定的字符串连接到该字符串的末尾.</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.concat(<span class="hljs-string">&quot;**hello itheima&quot;</span>);<br>        System.out.println(s2);<span class="hljs-comment">// helloworld**hello itheima</span><br>        <br>        <span class="hljs-comment">// char charAt(int index):获取指定索引处的字符</span><br>        System.out.println(s.charAt(<span class="hljs-number">0</span>));<br>        System.out.println(s.charAt(<span class="hljs-number">1</span>));<br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">// int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1</span><br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;l&quot;</span>));<br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;owo&quot;</span>));<br>        System.out.println(s.indexOf(<span class="hljs-string">&quot;ak&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">// String substring(int start):从start开始截取字符串到字符串结尾</span><br>        System.out.println(s.substring(<span class="hljs-number">0</span>));<br>        System.out.println(s.substring(<span class="hljs-number">5</span>));<br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">// String substring(int start,int end):从start到end截取字符串。含start，不含end。</span><br>        System.out.println(s.substring(<span class="hljs-number">0</span>, s.length()));<br>        System.out.println(s.substring(<span class="hljs-number">3</span>,<span class="hljs-number">8</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="转换功能的方法"><a href="#转换功能的方法" class="headerlink" title="转换功能的方法"></a>转换功能的方法</h4><ul>
<li><code>public char[] toCharArray ()</code> ：将此字符串转换为新的字符数组。</li>
<li><code>public byte[] getBytes ()</code> ：使用平台的默认字符集将该 String编码转换为新的字节数组。</li>
<li><code>public String replace (CharSequence target, CharSequence replacement)</code> ：将与target匹配的字符串使用replacement字符串替换。、</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String_Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建字符串对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abcde&quot;</span>;<br>        <br>        <span class="hljs-comment">// char[] toCharArray():把字符串转换为字符数组</span><br>        <span class="hljs-type">char</span>[] chs = s.toCharArray();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; chs.length; x++) &#123;<br>            System.out.println(chs[x]);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">// byte[] getBytes ():把字符串转换为字节数组</span><br>        <span class="hljs-type">byte</span>[] bytes = s.getBytes();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; bytes.length; x++) &#123;<br>            System.out.println(bytes[x]);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>        <br>        <span class="hljs-comment">// 替换字母it为大写IT</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;itcast itheima&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">replace</span> <span class="hljs-operator">=</span> str.replace(<span class="hljs-string">&quot;it&quot;</span>, <span class="hljs-string">&quot;IT&quot;</span>);<br>        System.out.println(replace); <span class="hljs-comment">// ITcast ITheima</span><br>        System.out.println(<span class="hljs-string">&quot;‐‐‐‐‐‐‐‐‐‐‐&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。</p>
</blockquote>
<h4 id="分割功能的方法"><a href="#分割功能的方法" class="headerlink" title="分割功能的方法"></a>分割功能的方法</h4><ul>
<li><code>public String[] split(String regex)</code> ：将此字符串按照给定的regex（规则）拆分为字符串数组。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String_Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建字符串对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aa|bb|cc&quot;</span>;<br>        String[] strArray = s.split(<span class="hljs-string">&quot;|&quot;</span>); <span class="hljs-comment">// [&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; x &lt; strArray.length; x++) &#123;<br>            System.out.println(strArray[x]); <span class="hljs-comment">// aa bb cc</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><hr>
<h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>关于 <code>static</code> 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是<strong>属于类</strong>的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p>
<h3 id="定义和使用格式"><a href="#定义和使用格式" class="headerlink" title="定义和使用格式"></a>定义和使用格式</h3><h4 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h4><p>当 <code>static</code> 修饰成员变量时，该变量称为<strong>类变量</strong>。该类的每个对象都<strong>共享</strong>同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</p>
<ul>
<li><strong>类变量</strong>：使用 <code>static</code> 关键字修饰的成员变量。</li>
</ul>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> 数据类型 变量名;<br></code></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>当 <code>static</code> 修饰成员方法时，该方法称为 <code>类方法</code> 。静态方法在声明中有 <code>static</code> ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。</p>
<ul>
<li><strong>类方法</strong>：使用 <code>static</code> 关键字修饰的成员方法，习惯称为<strong>静态方法</strong>。</li>
</ul>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">static</span> 返回值类型 方法名 (参数列表)&#123;<br>    <span class="hljs-comment">// 执行语句</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>静态方法调用的注意事项</strong>：<ul>
<li>静态方法可以直接访问类变量和静态方法。</li>
<li>静态方法<strong>不能直接访问</strong>普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。</li>
<li>静态方法中，不能使用<strong>this</strong>关键字。</li>
</ul>
</li>
</ul>
<blockquote>
<p>小贴士：静态方法只能访问静态成员。</p>
</blockquote>
<h4 id="调用格式"><a href="#调用格式" class="headerlink" title="调用格式"></a>调用格式</h4><p>被 <code>static</code> 修饰的成员可以并且建议通过<strong>类名直接访问</strong>，虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用一个静态成员，但是不建议，会出现警告信息。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 访问类变量</span><br>类名.类变量名；<br><br><span class="hljs-comment">// 调用静态方法</span><br>类名.静态方法名(参数)；<br></code></pre></td></tr></table></figure>

<h3 id="静态原理图解"><a href="#静态原理图解" class="headerlink" title="静态原理图解"></a>静态原理图解</h3><p><code>static</code> 修饰的内容：</p>
<ul>
<li>是随着类的加载而加载的，且只加载一次。</li>
<li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。</li>
<li>它优先于对象存在，所以，可以被所有对象共享。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E9%9D%99%E6%80%81%E5%8E%9F%E7%90%86%E5%9B%BE%E8%A7%A3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><ul>
<li><strong>静态代码块</strong>：定义在成员位置，使用 <code>static</code> 修饰的代码块{ }。<ul>
<li>位置：类中方法外。</li>
<li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li>
</ul>
</li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassName</span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>作用：给类变量进行初始化赋值。用法演示，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> number;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; list;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// 给类变量赋值</span><br>        number = <span class="hljs-number">2</span>;<br>        list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>        <span class="hljs-comment">// 添加元素到集合中</span><br>        list.add(<span class="hljs-string">&quot;张三&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;李四&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况<br>下，去调用方法。下面将介绍两个工具类，来体现static 方法的便利。</p>
</blockquote>
<h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><hr>
<h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Arrays</code> 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。</p>
<h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><ul>
<li><code>public static String toString(int[] a)</code> ：返回指定数组内容的字符串表示形式.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 定义int 数组</span><br><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">34</span>,<span class="hljs-number">35</span>,<span class="hljs-number">4</span>,<span class="hljs-number">657</span>,<span class="hljs-number">8</span>,<span class="hljs-number">69</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 打印数组,输出地址值</span><br>System.out.println(arr); <span class="hljs-comment">// [I@2ac1fdc4</span><br>    <br><span class="hljs-comment">// 数组内容转为字符串</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Arrays.toString(arr);<br><span class="hljs-comment">// 打印字符串,输出内容</span><br>System.out.println(s); <span class="hljs-comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>public static void sort(int[] a)</code> ：对指定的 int 型数组按数字升序进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 定义int 数组</span><br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">24</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">48</span>, <span class="hljs-number">4</span>, <span class="hljs-number">46</span>, <span class="hljs-number">35</span>, <span class="hljs-number">11</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;;<br>    System.out.println(<span class="hljs-string">&quot;排序前:&quot;</span>+ Arrays.toString(arr)); <span class="hljs-comment">// 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6,2]</span><br>        <span class="hljs-comment">// 升序排序</span><br>        Arrays.sort(arr);<br>    System.out.println(<span class="hljs-string">&quot;排序后:&quot;</span>+ Arrays.toString(arr));<span class="hljs-comment">// 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46,48]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><hr>
<h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p>
<h3 id="基本运算的方法"><a href="#基本运算的方法" class="headerlink" title="基本运算的方法"></a>基本运算的方法</h3><ul>
<li><code>public static double abs(double a)</code> ：返回 double 值的绝对值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> Math.abs(‐<span class="hljs-number">5</span>); <span class="hljs-comment">//d1的值为5</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> Math.abs(<span class="hljs-number">5</span>); <span class="hljs-comment">//d2的值为5</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> Math.ceil(<span class="hljs-number">3.3</span>); <span class="hljs-comment">//d1的值为 4.0</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> Math.ceil(‐<span class="hljs-number">3.3</span>); <span class="hljs-comment">//d2的值为 ‐3.0</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> Math.ceil(<span class="hljs-number">5.1</span>); <span class="hljs-comment">//d3的值为 6.0</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>public static double floor(double a)</code> ：返回小于等于参数最大的整数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> Math.floor(<span class="hljs-number">3.3</span>); <span class="hljs-comment">//d1的值为3.0</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> Math.floor(‐<span class="hljs-number">3.3</span>); <span class="hljs-comment">//d2的值为‐4.0</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> Math.floor(<span class="hljs-number">5.1</span>); <span class="hljs-comment">//d3的值为 5.0</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>public static long round(double a)</code> ：返回最接近参数的 long。(相当于四舍五入方法)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> Math.round(<span class="hljs-number">5.5</span>); <span class="hljs-comment">//d1的值为6.0</span><br><span class="hljs-type">long</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> Math.round(<span class="hljs-number">5.4</span>); <span class="hljs-comment">//d2的值为5.0</span><br></code></pre></td></tr></table></figure>

<h1 id="继承、super、this、抽象类"><a href="#继承、super、this、抽象类" class="headerlink" title="继承、super、this、抽象类"></a>继承、super、this、抽象类</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><hr>
<h3 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>多个类中存在相同属性和行为时，将这些内容抽取到单独的一个类中，那么多个类无需再定义这些属性和行为，只要继承一个类即可。</p>
<p>其中，多个类可以称为<strong>子类</strong>，单独那一个类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p>
<p>继承描述的是事物之间的所属关系，这种关系是： <code>is-a</code> 的关系。例如，图中兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非<strong>私有</strong>的属性和行为</li>
</ul>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ol>
<li>提高<strong>代码的复用性</strong>。</li>
<li>类与类之间产生了关系，是<strong>多态的前提</strong>。</li>
</ol>
<h3 id="继承的格式"><a href="#继承的格式" class="headerlink" title="继承的格式"></a>继承的格式</h3><p>通过 <code>extends</code> 关键字，可以声明一个子类继承另一个父类，定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">class 父类 &#123;<br>    ...<br>&#125;<br><br>class 子类 extends 父类 &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 定义员工类Employee，做为父类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    String name; <span class="hljs-comment">// 定义name属性</span><br>    <span class="hljs-comment">// 定义员工的工作方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;尽心尽力地工作&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 定义讲师类Teacher 继承 员工类Employee</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-comment">// 定义一个打印name的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;name=&quot;</span> + name);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 定义测试类</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendDemo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个讲师类对象</span><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <br>        <span class="hljs-comment">// 为该员工类的name属性进行赋值</span><br>        t.name = <span class="hljs-string">&quot;小明&quot;</span>;<br>        <br>        <span class="hljs-comment">// 调用该员工的printName()方法</span><br>        t.printName(); <span class="hljs-comment">// name = 小明</span><br>        <br>        <span class="hljs-comment">// 调用Teacher类继承来的work()方法</span><br>        t.work(); <span class="hljs-comment">// 尽心尽力地工作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="继承后的特点——成员变量"><a href="#继承后的特点——成员变量" class="headerlink" title="继承后的特点——成员变量"></a>继承后的特点——成员变量</h3><h4 id="成员变量不重名"><a href="#成员变量不重名" class="headerlink" title="成员变量不重名"></a>成员变量不重名</h4><p>如果子类父类中出现<strong>不重名</strong>的成员变量，这时的访问是<strong>没有影响的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">// Fu中的成员变量。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">// Zi中的成员变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// Zi中的成员方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 访问父类中的num，</span><br>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span>+num); <span class="hljs-comment">// 继承而来，所以直接访问。</span><br>        <span class="hljs-comment">// 访问子类中的num2</span><br>        System.out.println(<span class="hljs-string">&quot;Zi num2=&quot;</span>+num2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendDemo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建子类对象</span><br>        <span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>        <span class="hljs-comment">// 调用子类中的show方法</span><br>        z.show();<br>    &#125;<br>&#125;<br><br>演示结果：<br><span class="hljs-type">Fu</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<h4 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h4><p>如果子类父类出现<strong>重名</strong>的成员变量，这时的访问是<strong>有影响的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">// Fu中的成员变量。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">// Zi中的成员变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 访问父类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + num);<br>        <span class="hljs-comment">// 访问子类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + num);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建子类对象</span><br>        <span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>        <span class="hljs-comment">// 调用子类中的show方法</span><br>        z.show();<br>    &#125;<br>&#125;<br><br>演示结果：<br><span class="hljs-type">Fu</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用 <code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p>
<p>使用格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">super</span>.父类成员变量名<br></code></pre></td></tr></table></figure>

<p>子类方法需要修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">// Zi中的成员变量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//访问父类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Fu num=&quot;</span> + <span class="hljs-built_in">super</span>.num);<br>        <span class="hljs-comment">//访问子类中的num</span><br>        System.out.println(<span class="hljs-string">&quot;Zi num=&quot;</span> + <span class="hljs-built_in">this</span>.num);<br>    &#125;<br>&#125;<br><br>演示结果：<br><span class="hljs-type">Fu</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span><br><span class="hljs-type">Zi</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：Fu 类中的成员变量是非私有的，子类中可以直接访问。若Fu 类中的成员变量私有了，子类是不能直接访问的。通常编码时，我们遵循封装的原则，使用private修饰成员变量，那么如何访问父类的私有成员变量呢？对！可以在父类中提供公共的getXxx方法和setXxx方法。</p>
</blockquote>
<h3 id="继承后的特点——成员方法"><a href="#继承后的特点——成员方法" class="headerlink" title="继承后的特点——成员方法"></a>继承后的特点——成员方法</h3><h4 id="成员方法不重名"><a href="#成员方法不重名" class="headerlink" title="成员方法不重名"></a>成员方法不重名</h4><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Fu类中的show方法执行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Zi类中的show2方法执行&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo04</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>        <span class="hljs-comment">//子类中没有show方法，但是可以找到父类方法去执行</span><br>        z.show();<br>        z.show2();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h4><p>如果子类父类中出现<strong>重名</strong>的成员方法，这时的访问是一种特殊情况，叫做<strong>方法重写</strong> (Override)。</p>
<ul>
<li><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Fu show&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-comment">//子类重写了父类的show方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Zi show&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo05</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Zi</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>        <span class="hljs-comment">// 子类中有show方法，只执行重写后的show方法</span><br>        z.show(); <span class="hljs-comment">// Zi show</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li>
<li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li>
</ol>
<h3 id="继承后的特点——构造方法"><a href="#继承后的特点——构造方法" class="headerlink" title="继承后的特点——构造方法"></a>继承后的特点——构造方法</h3><p>当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？</p>
<p>首先我们要回忆两个事情，构造方法的定义格式和作用。</p>
<ol>
<li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li>
<li>构造方法的作用是初始化成员变量的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个 <code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fu</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br>    Fu()&#123;<br>        System.out.println(<span class="hljs-string">&quot;Fu()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fu</span> &#123;<br>    Zi()&#123;<br>        <span class="hljs-comment">// super（），调用父类构造方法</span><br>        <span class="hljs-built_in">super</span>();<br>        System.out.println(<span class="hljs-string">&quot;Zi（）&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExtendsDemo07</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">Zi</span> <span class="hljs-variable">zi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>    &#125;<br>&#125;<br><br>输出结果：<br>Fu（）<br>Zi（）<br></code></pre></td></tr></table></figure>

<h3 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h3><hr>
<h4 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h4><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构造方法调用时，一定先调用父类的构造方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/super%E4%B8%8Ethis%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h4><ul>
<li><strong>super</strong> ：代表父类的<strong>存储空间标识</strong>(可以理解为父亲的引用)。</li>
<li><strong>this</strong> ：代表<strong>当前对象的引用</strong>(谁调用就代表谁)。</li>
</ul>
<h4 id="super和this的用法"><a href="#super和this的用法" class="headerlink" title="super和this的用法"></a>super和this的用法</h4><ol>
<li><p>访问成员</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.成员变量 <span class="hljs-comment">// 本类的</span><br><span class="hljs-built_in">super</span>.成员变量 <span class="hljs-comment">// 父类的</span><br><br><span class="hljs-built_in">this</span>.成员方法名() <span class="hljs-comment">// 本类的</span><br><span class="hljs-built_in">super</span>.成员方法名() <span class="hljs-comment">// 父类的</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>访问构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>(...) <span class="hljs-comment">// 本类的构造方法</span><br><span class="hljs-built_in">super</span>(...) <span class="hljs-comment">// 父类的构造方法</span><br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</p>
</blockquote>
<h3 id="继承的特点"><a href="#继承的特点" class="headerlink" title="继承的特点"></a>继承的特点</h3><ol>
<li><p>Java只支持单继承，不支持多继承。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//一个类只能有一个父类，不可以有多个父类。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;&#125; <span class="hljs-comment">//ok</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>，B... <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>Java支持多层继承(继承体系)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">B</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>顶层父类是Object类。所有的类默认继承Object，作为父类。</p>
</blockquote>
</li>
<li><p>子类和父类是一种相对的概念。</p>
</li>
</ol>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><hr>
<h3 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h3><h4 id="由来-1"><a href="#由来-1" class="headerlink" title="由来"></a>由来</h4><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类就是<strong>抽象类</strong>。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><strong>抽象方法</strong> ： 没有方法体的方法。</li>
<li><strong>抽象类</strong>：包含抽象方法的类。</li>
</ul>
<h3 id="abstract使用格式"><a href="#abstract使用格式" class="headerlink" title="abstract使用格式"></a>abstract使用格式</h3><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>使用 <code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">abstract</span> 返回值类型 方法名 (参数列表)；<br></code></pre></td></tr></table></figure>

<h4 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h4><p>如果一个类包含抽象方法，那么该类必须是抽象类。</p>
<p>定义格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> class 类名字 &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="抽象的使用"><a href="#抽象的使用" class="headerlink" title="抽象的使用"></a>抽象的使用</h4><p>继承抽象类的子类<strong>必须重写父类所有的抽象方法</strong>。否则，该子类也必须声明为抽象类。最终，必须有子类实现该父类的抽象方法，否则，从最初的父类到最终的子类都不能创建对象，失去意义。</p>
<p>此时的方法重写，是子类对父类抽象方法的完成实现，我们将这种方法重写的操作，也叫做<strong>实现方法</strong>。</p>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p>
<ol>
<li><p>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。</p>
<blockquote>
<p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p>
</blockquote>
</li>
<li><p>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。</p>
<blockquote>
<p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p>
</blockquote>
</li>
<li><p>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>
<blockquote>
<p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p>
</blockquote>
</li>
<li><p>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。</p>
<blockquote>
<p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p>
</blockquote>
</li>
</ol>
<h1 id="接口、多态"><a href="#接口、多态" class="headerlink" title="接口、多态"></a>接口、多态</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><hr>
<h3 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h3><p>接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法</strong>，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。</p>
<p>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
<blockquote>
<p>引用数据类型：数组，类，接口。</p>
</blockquote>
<p>接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p>
<h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> interface 接口名称 &#123;<br>	<span class="hljs-comment">//抽象方法</span><br>    <span class="hljs-comment">//默认方法</span><br>    <span class="hljs-comment">//静态方法</span><br>    <span class="hljs-comment">//私有方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="含有抽象方法"><a href="#含有抽象方法" class="headerlink" title="含有抽象方法"></a>含有抽象方法</h4><p>抽象方法：使用 <code>abstract</code> 关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterFaceName</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="含有默认方法和静态方法"><a href="#含有默认方法和静态方法" class="headerlink" title="含有默认方法和静态方法"></a>含有默认方法和静态方法</h4><p>默认方法：使用 <code>default</code> 修饰，不可省略，供子类调用或者重写。</p>
<p>静态方法：使用 <code>static</code> 修饰，供接口直接调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterFaceName</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-comment">//执行语句</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="含有私有方法和私有静态方法"><a href="#含有私有方法和私有静态方法" class="headerlink" title="含有私有方法和私有静态方法"></a>含有私有方法和私有静态方法</h4><p>私有方法：使用 <code>private</code> 修饰，供接口中的默认方法或者静态方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterFaceName</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//执行语句</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基本的实现"><a href="#基本的实现" class="headerlink" title="基本的实现"></a>基本的实现</h3><h4 id="实现的概述"><a href="#实现的概述" class="headerlink" title="实现的概述"></a>实现的概述</h4><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code>implements</code> 关键字。</p>
<p>非抽象子类实现接口：</p>
<ol>
<li>必须重写接口中所有抽象方法。</li>
<li>继承了接口的默认方法，即可以直接调用，也可以重写。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 implements 接口名 &#123;<br>	<span class="hljs-comment">//重写接口中抽象方法【必须】</span><br>    <span class="hljs-comment">//重写接口中默认方法【可选】</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="抽象方法的使用"><a href="#抽象方法的使用" class="headerlink" title="抽象方法的使用"></a>抽象方法的使用</h4><p>必须全部实现</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-comment">//定义抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;吃东西&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;晚上睡&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建子类对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        <span class="hljs-comment">//调用实现后的方法</span><br>        a.eat();<br>        a.sleep();<br>    &#125;<br>&#125;<br>输出结果：<br>吃东西<br>晚上睡<br></code></pre></td></tr></table></figure>

<h4 id="默认方法的使用"><a href="#默认方法的使用" class="headerlink" title="默认方法的使用"></a>默认方法的使用</h4><p>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。</p>
<ol>
<li><p>继承默认方法</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-comment">//继承，什么都不用写，直接调用</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建子类对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        <span class="hljs-comment">//调用默认方法</span><br>        a.fly();<br>    &#125;<br>&#125;<br>输出结果：<br>天上飞<br></code></pre></td></tr></table></figure>
</li>
<li><p>重写默认方法</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;天上飞&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;自由自在的飞&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建子类对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Animal</span>();<br>        <span class="hljs-comment">//调用重写方法</span><br>        a.fly();<br>    &#125;<br>&#125;<br>输出结果：<br>自由自在的飞<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="静态方法的使用"><a href="#静态方法的使用" class="headerlink" title="静态方法的使用"></a>静态方法的使用</h4><p>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-comment">//无法重写静态方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterFaceDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//Animal.run(); //【错误】无法继承方法，也无法调用</span><br>        LivaAble.run();<br>    &#125;<br>&#125;<br>输出结果：<br>跑起来~~~<br></code></pre></td></tr></table></figure>

<h4 id="私有方法的使用"><a href="#私有方法的使用" class="headerlink" title="私有方法的使用"></a>私有方法的使用</h4><ul>
<li>私有方法：只有默认方法可以调用</li>
<li>私有静态方法：默认方法和静态方法可以调用</li>
</ul>
<p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法静态方法的辅助。同学们在已学技术的基础上，可以自行测试。</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LiveAble</span> &#123;<br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">()</span>&#123;<br>        func1();<br>        func2();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;跑起来~~~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h3><p>之前学过，在继承体系中，一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<strong>多实现</strong>。并且，一个类能继承一个父类，同时实现多个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">class 类名 [extends 父类名] implements 接口名<span class="hljs-number">1</span>，接口名<span class="hljs-number">2</span>，接口名<span class="hljs-number">3.</span>..&#123;<br>    <span class="hljs-comment">//重写接口中抽象方法【必须】</span><br>    <span class="hljs-comment">//重写接口中默认方法【不重写时可选】</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="抽象方法-1"><a href="#抽象方法-1" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法。<strong>如果抽象方法有重名，只需要重写一次</strong>。</p>
<p>定义多个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showA</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showB</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showA</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;showA&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showB</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;showB&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;show&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>接口中，有多个默认方法时，实现类都可继承使用。<strong>如果默认方法有重名的，必须重写一次</strong>。</p>
<p>定义多个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>,B &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h4><p>接口中，存在同名的静态方法并不会冲突，原因只能通过各自接口名访问静态方法。</p>
<h4 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h4><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AAAAAAAAAAA&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;DDDDDDDDDDD&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//未重写methodA方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(Strong[] args)</span>&#123;<br>        <span class="hljs-type">C</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>        c.methodA();<br>    &#125;<br>&#125;<br>输出结果：<br>DDDDDDDDDDD<br></code></pre></td></tr></table></figure>

<h4 id="接口的多继承【了解】"><a href="#接口的多继承【了解】" class="headerlink" title="接口的多继承【了解】"></a>接口的多继承【了解】</h4><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 <code>extends</code>关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法又重名的，那么子接口需要重写一次</strong>。</p>
<p>定义父接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AAAAAAAAAAAAAAAAAAA&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;BBBBBBBBBBBBBBBBBBB&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义子接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">D</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>,B &#123;<br>    <span class="hljs-meta">@override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;DDDDDDDDDDDDDD&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：</p>
<p>子接口重写默认方法时，default关键字可以保留。</p>
<p>子类重写默认方法时，default关键字不可以保留</p>
</blockquote>
<h3 id="其他成员特点"><a href="#其他成员特点" class="headerlink" title="其他成员特点"></a>其他成员特点</h3><ul>
<li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用 public static final 修饰。</li>
<li>接口中，没有构造方法，不能创建对象。</li>
<li>接口中，没有静态代码块。</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><hr>
<h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>多态是继封装、继承之后，面向对象的第三大特性。</p>
<p>生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。在比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，是可以体现出来的不同的状态。多态，描述的就是这样的状态。</p>
<h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul>
<li><strong>多态</strong>：是指同一行为没具有多个不同表现形式。</li>
</ul>
<h4 id="前提【重点】"><a href="#前提【重点】" class="headerlink" title="前提【重点】"></a>前提【重点】</h4><ol>
<li>继承或者实现【二选一】</li>
<li>方法的重写【意义体现：不重写，无意义】</li>
<li>父类引用指向子类对象【格式体现】</li>
</ol>
<h3 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h3><p>多态的体现的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类对象;<br>变量名方法名();<br></code></pre></td></tr></table></figure>

<blockquote>
<p>父类类型：指子类对象继承的父类类型，或者实现的父类接口类型。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Fu</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Zi</span>();<br>f.method();<br></code></pre></td></tr></table></figure>

<p><strong>当使用多态调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的时子类重写后方法。</strong></p>
<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//多态形式，创建对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-comment">//调用的时 Cat 的 eat</span><br>        a1.eat();<br>        <br>        <span class="hljs-comment">//多态形式，创建对象</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <span class="hljs-comment">//调用的时 Dog 的 eat</span><br>        a2.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h3><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p>
<p>定义父类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//多态形式，创建对象</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>        <br>        <span class="hljs-comment">//调用showCatEat</span><br>        showCatEat(c);<br>        <span class="hljs-comment">//调用showDogEat</span><br>    	showDogEat(d);<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代</span><br><span class="hljs-comment">        而执行效果一致</span><br><span class="hljs-comment">        */</span><br>        showAnimalEat(c);<br>        showAnimalEat(d);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showCatEat</span><span class="hljs-params">(Cat c)</span>&#123;<br>        c.eat();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showDogEat</span><span class="hljs-params">(Dog d)</span>&#123;<br>        d.eat();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAnimalEat</span><span class="hljs-params">(Animal a)</span>&#123;<br>        a.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以吧Cat对象和Dog对象，传递给方法。</p>
<p>当然eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上俩种方法。</p>
<p>不仅仅是代替，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</p>
<p>  所以、多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p>
<h3 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h3><p>多态的转换分为向上转型与向下转型俩种：</p>
<h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><ul>
<li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</li>
</ul>
<p>当父类引用指向一个子类对象时，便是向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类类型();<br><span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure>

<h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><ul>
<li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。</li>
</ul>
<p>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">子类类型 变量名 = (子类类型)父类变量名;<br><span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat) a;<br></code></pre></td></tr></table></figure>

<h4 id="为什么要转型"><a href="#为什么要转型" class="headerlink" title="为什么要转型"></a>为什么要转型</h4><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点“小麻烦”。所以，想要调用子类特有的方法必须做向下转型。</p>
<p>定义类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;吃鱼&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">catchMouse</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;抓老鼠&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;吃骨头&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">watchHouse</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;看家&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//向上转型</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        a.eat(); <span class="hljs-comment">//调用的是 Cat 的 eat</span><br>        <br>        <span class="hljs-comment">//向下转型</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;<br>        c.catchMouse(); <span class="hljs-comment">//调用的是 Cat 的 catchMouse</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="转型的异常"><a href="#转型的异常" class="headerlink" title="转型的异常"></a>转型的异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//向上转型</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        a.eat(); <span class="hljs-comment">//调用的是 Cat 的 eat</span><br>        <br>        <span class="hljs-comment">//向下转型</span><br>        <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<br>        d.watchHouse(); <span class="hljs-comment">//调用的是 Dog 的 watchHouse 【运行报错】</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码可以通过编译，但是运行时，却报出了 <code>ClassCastException</code> ，类型转换异常！这是因为，明明创建了<br>Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。</p>
<p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">变量名 <span class="hljs-keyword">instanceof</span> 数据类型<br>如果变量属于该数据类型，返回<span class="hljs-literal">true</span>。<br>如果变量不属于该数据类型，返回<span class="hljs-literal">false</span>。<br></code></pre></td></tr></table></figure>

<p>所以，转换前，我们最好做一个判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//向上转型</span><br>        <span class="hljs-type">Animal</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        a.eat(); <span class="hljs-comment">//调用的是 Cat 的 eat</span><br>        <br>        <span class="hljs-comment">//向下转型</span><br>        <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Cat)&#123;<br>            <span class="hljs-type">Cat</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (Cat)a;<br>            c.catchMouse(); <span class="hljs-comment">//调用的是 Cat 的 catchMouse</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a <span class="hljs-keyword">instanceof</span> Dog)&#123;<br>            <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> (Dog)a;<br>            d.watchHouse(); <span class="hljs-comment">//调用的是 Dog 的 watchHouse</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="final、权限、内部类"><a href="#final、权限、内部类" class="headerlink" title="final、权限、内部类"></a>final、权限、内部类</h1><h2 id="第一章-final关键字"><a href="#第一章-final关键字" class="headerlink" title="第一章 final关键字"></a>第一章 final关键字</h2><hr>
<h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><p>学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。那么我们能不能随意的继承API中提供的类，改写其内容呢？显然这是不合适的。为了避免这种随意改写的情况，Java提供 <code>final</code> 关键字，用于修饰<strong>不可改写</strong>内容。</p>
<ul>
<li><strong>final</strong>：不可改变。可以用于修饰类、方法和变量。<ul>
<li>类：被修饰的类，不能被继承。</li>
<li>方法：被修饰的方法，不能被重写。</li>
<li>变量：被修饰的变量，不能被重新赋值。</li>
</ul>
</li>
</ul>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> class 类名 &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>查询API发现像 <code>public final class String</code> 、 <code>public final class Math</code> 、 <code>public final class Scanner</code> 等，很多都是被final修饰的，目的就是供我们使用，而不让我们所以改变其内容。</p>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 <span class="hljs-keyword">final</span> 返回值类型 方法名(参数列表)&#123;<br>    <span class="hljs-comment">//方法体</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>重写被 <code>final</code> 修饰的方法，编译时就会报错。</p>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><ol>
<li><p><strong>局部变量——基本类型</strong></p>
<p>基本类型的局部变量，被 <code>final</code> 修饰后，只能赋值一次，不能再更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//声明变量，使用final修饰</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> a;<br>        <span class="hljs-comment">//第一次赋值</span><br>        a = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//第二次赋值</span><br>        a = <span class="hljs-number">20</span>;<span class="hljs-comment">//报错，不可重新赋值</span><br>        <br>        <br>        <span class="hljs-comment">//声明变量，直接赋值，使用final修饰</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//第二次赋值</span><br>        b = <span class="hljs-number">20</span>;<span class="hljs-comment">//报错，不可重新赋值</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>局部变量——引用类型</strong></p>
<p>引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。但是不影响对象内部的成员变量值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建User对象</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        <span class="hljs-comment">//创建另一个user对象</span><br>        u = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//报错，指向了新的对象，地址值改变</span><br>        <br>        <span class="hljs-comment">//调用setName方法</span><br>        u.setName(<span class="hljs-string">&quot;张三&quot;</span>);<span class="hljs-comment">//可以修改</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>成员变量</strong></p>
<p>成员变量涉及到初始化的问题，初始化方法有两种，只能二选一：</p>
<ul>
<li><p>显示初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USERNAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造方法初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">final</span> String USERNAME;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username,<span class="hljs-type">int</span> age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.USERNAME = username;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<blockquote>
<p>被final修饰的常量名称，一般都有书写格式，所有字母都<strong>大写</strong>。</p>
</blockquote>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><hr>
<h3 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h3><p>在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限</p>
<ul>
<li>public：公共的</li>
<li>protected：受保护的</li>
<li>default：默认的</li>
<li>private：私有的</li>
</ul>
<h3 id="不同权限的访问能力"><a href="#不同权限的访问能力" class="headerlink" title="不同权限的访问能力"></a>不同权限的访问能力</h3><table>
<thead>
<tr>
<th align="left"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">default（空的）</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">同一类中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="left">同一包中（子类与无关类）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">不同包的子类</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="left">不同包中的无关类</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>可见，public具有最大权限。private则时最小权限。 </p>
<p>编写代码时，如果没有特殊的 考虑，建议这样使用权限：</p>
<ul>
<li>成员变量使用 <code>private</code> ，隐藏细节。</li>
<li>构造方法使用 <code>public</code> ，方便创建对象。</li>
<li>成员方法使用 <code>public</code> ，方便调用方法。</li>
</ul>
<blockquote>
<p>小贴士：不加权限修饰符，其访问能力与default修饰符相同</p>
</blockquote>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><hr>
<h3 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h3><h4 id="什么时内部类"><a href="#什么时内部类" class="headerlink" title="什么时内部类"></a>什么时内部类</h4><p>将一个类A定义在类一个类B里面，里面的那个类就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。</p>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li><strong>成员内部类</strong>：定义在<strong>类中方法外</strong>的类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">class 外部类 &#123;<br>    class 内部类 &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在描述事物时，若一个事物内部还包含其他事物，就可以使用内部类这样结构。比如，汽车类 <code>Car</code> 中包含发动机类 <code>Engine</code> ，这时，<code>Engine</code> 就可以使用内部类来描述，定义在成员位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<span class="hljs-comment">//外部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engne</span> &#123;<span class="hljs-comment">//内部类</span><br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="访问特点"><a href="#访问特点" class="headerlink" title="访问特点"></a>访问特点</h4><ul>
<li>内部类可以直接访问外部类的成员，包括私有成员。</li>
<li>外部类要访问内部类的成员，必须要建立内部类的对象。</li>
</ul>
<p>创建内部类格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类名.内部类名 对象名 = <span class="hljs-keyword">new</span> 外部类型().new 内部类型();<br></code></pre></td></tr></table></figure>

<p>访问演示，代码如下：</p>
<p>定义类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">live</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Heart</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">jump</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//直接访问外部类成员</span><br>            <span class="hljs-keyword">if</span>(live) &#123;<br>                System.out.println(<span class="hljs-string">&quot;心脏在跳动&quot;</span>)；<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;心脏不跳了&quot;</span>)；<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">isLivae</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> live;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLive</span><span class="hljs-params">(<span class="hljs-type">boolean</span> live)</span> &#123;<br>        <span class="hljs-built_in">this</span>.live = live;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建外部类对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">//创建内部类对象</span><br>        <span class="hljs-type">Heart</span> <span class="hljs-variable">heart</span> <span class="hljs-operator">=</span> p.new.Heart();<br>        <br>        <span class="hljs-comment">//调用内部类方法</span><br>        heart.jump();<br>        <span class="hljs-comment">//调用外部类方法</span><br>        p.setLive(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//调用内部类方法</span><br>        heart.jump();<br>    &#125;<br>&#125;<br>输出结果：<br>心脏在跳动<br>心脏不跳了<br></code></pre></td></tr></table></figure>

<blockquote>
<p>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号。</p>
<p>比如，Person$Heart.class</p>
</blockquote>
<h3 id="匿名内部类【重点】"><a href="#匿名内部类【重点】" class="headerlink" title="匿名内部类【重点】"></a>匿名内部类【重点】</h3><ul>
<li><strong>匿名内部类</strong>：是内部类的简化写法。它的本质是一个 <code>带具体实现的</code> <code>父类或者父接口的</code> <code>匿名的</code> <strong>子类对象</strong>。</li>
</ul>
<p>开发中，最常用到的内部类就是匿名内部类了，以接口举例，当你使用一个接口时，视乎得做如下几步操作，</p>
<ol>
<li>定义子类</li>
<li>重写接口中的方法</li>
<li>创建子类对象</li>
<li>调用重写后的方法</li>
</ol>
<p>我们的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成异步呢？匿名内部类就是做这样的快捷方式。</p>
<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> 父类名或者接口名()&#123;<br>    <span class="hljs-comment">//方法重写</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//执行语句</span><br>    &#125;<br>&#125;；<br></code></pre></td></tr></table></figure>

<h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><p>以接口为例，匿名内部类的使用。</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FlyAble</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建匿名内部类，并调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerDemo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.等号右边：是匿名内部类，定义并创建该接口的子类对象</span><br><span class="hljs-comment">        2.等号左边：是多态赋值，接口类型引用指向子类对象</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">FlyAble</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyAble</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);  <br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-comment">//调用 fly方法，执行重写后的方法</span><br>        f.fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通常在方法的形式参数是接口或者抽象类时，也可以将匿名内部类作为参数传递。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerDemo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        1.等号右边：定义并创建该接口的子类对象</span><br><span class="hljs-comment">        2.等号左边：是多态,接口类型引用指向子类对象</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">FlyAble</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyAble</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">//将f传递给showFly方法中</span><br>        showFly(f);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFly</span><span class="hljs-params">(FlyAble f)</span> &#123;<br>        f.fly();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上两步，也可以简化为一步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerDemo3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">       创建匿名内部类，直接传递给showFly(FlyAble f)</span><br><span class="hljs-comment">        */</span><br>        showFly(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlyAble</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;我飞了~~~&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFly</span><span class="hljs-params">(FlyAble f)</span> &#123;<br>        f.fly();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="引用类型用法总结"><a href="#引用类型用法总结" class="headerlink" title="引用类型用法总结"></a>引用类型用法总结</h2><hr>
<p>实际的开发中，引用类型的使用非常重要，也是非常普遍的。我们可以在理解基本类型的使用方式基础上，进一步去掌握引用类型的使用方式。基本类型可以作为变量、作为方法的参数、作为方法的返回值，那么当然引用类型也是可以的。</p>
<h3 id="class作为成员变量"><a href="#class作为成员变量" class="headerlink" title="class作为成员变量"></a>class作为成员变量</h3><p>再定义一个类Role（游戏角色）时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> &#123;<br>    <span class="hljs-type">int</span> id;<span class="hljs-comment">//角色id</span><br>    <span class="hljs-type">int</span> blood;<span class="hljs-comment">//生命值</span><br>    String name;<span class="hljs-comment">//角色名称</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用 <code>int</code> 类型表示角色id和生命值，使用 <code>String</code> 类型表示姓名。此时，<code>String</code> 本身就是引用类型，由于使用的方式类似常量，所以往往忽略了它是引用类型的存在。如果我们继续丰富这个类的定义，给 <code>Role</code> 增加武器，穿戴装备等属性，我们将如何编写呢？</p>
<p>定义武器类，将增加攻击能力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">weapon</span> &#123;<br>    String name;<span class="hljs-comment">//武器名称</span><br>    <span class="hljs-type">int</span> hurt;<span class="hljs-comment">//伤害值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义穿戴盔甲类，将增加防御能力，也就是提升生命值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Armour</span> &#123;<br>    String name;<span class="hljs-comment">//装备名称</span><br>    <span class="hljs-type">int</span> protect;<span class="hljs-comment">//防御值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义角色类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> blood;<br>    String name;<br>    <span class="hljs-comment">//添加武器属性</span><br>    Weapon wp;<br>    <span class="hljs-comment">//添加盔甲属性</span><br>    Armour ar;<br>    <br>    <span class="hljs-comment">//提供get/set方法</span><br>    <span class="hljs-keyword">public</span> Weapon <span class="hljs-title function_">getWp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> wp;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWeapon</span><span class="hljs-params">(Weapon wp)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wp = wp;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Armour <span class="hljs-title function_">getArmour</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ar;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArmour</span><span class="hljs-params">(Armour ar)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ar = ar;<br>    &#125;<br><br>    <span class="hljs-comment">//攻击方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attack</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用&quot;</span>+ wp.getName() +<span class="hljs-string">&quot;, 造成&quot;</span>+wp.getHurt()+<span class="hljs-string">&quot;点伤害&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//穿戴盔甲</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wear</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">// 增加防御,就是增加blood值</span><br>        <span class="hljs-built_in">this</span>.blood += ar.getProtect();<br>        System.out.println(<span class="hljs-string">&quot;穿上&quot;</span>+ar.getName()+<span class="hljs-string">&quot;, 生命值增加&quot;</span>+ar.getProtect());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Weapon 对象</span><br>        <span class="hljs-type">Weapon</span> <span class="hljs-variable">wp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Weapon</span>(<span class="hljs-string">&quot;屠龙刀&quot;</span> , <span class="hljs-number">999999</span>);<br>        <span class="hljs-comment">// 创建Armour 对象</span><br>        <span class="hljs-type">Armour</span> <span class="hljs-variable">ar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Armour</span>(<span class="hljs-string">&quot;麒麟甲&quot;</span>,<span class="hljs-number">10000</span>);<br>        <span class="hljs-comment">// 创建Role 对象</span><br>        <span class="hljs-type">Role</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>();<br>        <br>        <span class="hljs-comment">// 设置武器属性</span><br>        r.setWeapon(wp);<br>        <br>        <span class="hljs-comment">// 设置盔甲属性</span><br>        r.setArmour(ar);<br>        <br>        <span class="hljs-comment">// 攻击</span><br>        r.attack();<br>        <span class="hljs-comment">// 穿戴盔甲</span><br>        r.wear();<br>    &#125;<br>&#125;<br>输出结果:<br>使用屠龙刀,造成<span class="hljs-number">999999</span>点伤害<br>穿上麒麟甲 ,生命值增加<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>类作为成员变量时，对它进行赋值的操作，实际上，是赋给它该类的一个对象。</p>
</blockquote>
<h3 id="interface作为成员变量"><a href="#interface作为成员变量" class="headerlink" title="interface作为成员变量"></a>interface作为成员变量</h3><p>接口是对方法的封装，对应游戏当中，可以看作是扩展游戏角色的技能。所以，如果想扩展更强大技能，我们在<br><code>Role</code> 中，可以增加接口作为成员变量，来设置不同的技能。</p>
<p>定义接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//法术攻击</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FaShuShill</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">faShuAttack</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义角色类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Role</span> &#123;<br>    FaShuSkill fs;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFaShuSkill</span><span class="hljs-params">(FaShuSkill fs)</span> &#123;<br>        <span class="hljs-built_in">this</span>.fs = fs;<br>    &#125;<br>    <br>    <span class="hljs-comment">//法术攻击</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">faShuSkillAttack</span><span class="hljs-params">()</span>&#123;<br>        System.out.print(<span class="hljs-string">&quot;发动法术攻击:&quot;</span>);<br>        fs.faShuAttack();<br>        System.out.println(<span class="hljs-string">&quot;攻击完毕&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建游戏角色</span><br>        <span class="hljs-type">Role</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Role</span>();<br>        <span class="hljs-comment">// 设置角色法术技能</span><br>        role.setFaShuSkill(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FaShuSkill</span>() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">faShuAttack</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;纵横天下&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 发动法术攻击</span><br>        role.faShuSkillAttack();<br>        <span class="hljs-comment">// 更换技能</span><br>        role.setFaShuSkill(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FaShuSkill</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">faShuAttack</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;逆转乾坤&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 发动法术攻击</span><br>        role.faShuSkillAttack();<br>    &#125;<br>&#125;<br>输出结果:<br>发动法术攻击:纵横天下<br>攻击完毕<br>    <br>发动法术攻击:逆转乾坤<br>攻击完毕<br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们使用一个接口，作为成员变量，以便随时更换技能，这样的设计更为灵活，增强了程序的扩展性。</p>
<p>接口作为成员变量时，对它进行赋值的操作，实际上，是赋给它该接口的一个子类对象。</p>
</blockquote>
<h3 id="interface作为方法参数和返回值类型"><a href="#interface作为方法参数和返回值类型" class="headerlink" title="interface作为方法参数和返回值类型"></a>interface作为方法参数和返回值类型</h3><p>当接口作为方法的参数时,需要传递什么呢？当接口作为方法的返回值类型时，需要返回什么呢？对，其实都是它的子类对象。 <code>ArrayList</code> 类我们并不陌生，查看API我们发现，实际上，它是 <code>java.util.List</code> 接口的实现类。所以，当我们看见 <code>List</code> 接口作为参数或者返回值类型时，当然可以将 <code>ArrayList</code> 的对象进行传递或返回。</p>
<p>请观察如下方法：<strong>获取某集合中所有的偶数</strong>。</p>
<p>定义方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">getEvenNum</span><span class="hljs-params">(List&lt;Integer&gt; list)</span> &#123;<br>    <span class="hljs-comment">//创建保存偶数的集合</span><br>    ArrayList&lt;Integer&gt; evenList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//遍历集合list,判断元素为偶数,就添加到evenList中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> list.get(i);<br>        <span class="hljs-keyword">if</span> (integer % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            evenList.add(integer);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    返回偶数集合</span><br><span class="hljs-comment">    因为getEvenNum</span><br><span class="hljs-comment">    因为getEvenNum方法的返回值类型是List,而ArrayList是List的子类,</span><br><span class="hljs-comment">    所以evenList可以返回</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> evenList;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ArrayList集合,并添加数字</span><br>        ArrayList&lt;Integer&gt; srcList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            srcList.add(i);<br>        &#125;<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        获取偶数集合</span><br><span class="hljs-comment">        因为getEvenNum方法的参数是List,而ArrayList是List的子类,</span><br><span class="hljs-comment">        所以srcList可以传递</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> getEvenNum(srcList);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>接口作为参数时，传递它的子类对象。</p>
<p>接口作为返回值类型时，返回它的子类对象。</p>
</blockquote>
<h1 id="常用类-1"><a href="#常用类-1" class="headerlink" title="常用类"></a>常用类</h1><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><hr>
<h3 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h3><p><code>java.lang.Object</code> 类</p>
<p>类 <code>Object</code> 是类层次结构的根（最顶层）类。每个类都使用 <code>Object</code> 作为超（父）类。所有对象（包括数组）都实现这个类的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-comment">/*extends Object*/</span> &#123;<br>  	<span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><h4 id="方法摘要"><a href="#方法摘要" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul>
<li><code>public String toString()</code>：返回该对象的字符串表示。</li>
</ul>
<p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p>
<p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p>
<h4 id="覆盖重写"><a href="#覆盖重写" class="headerlink" title="覆盖重写"></a>覆盖重写</h4><p>如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> + <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> + <span class="hljs-string">&quot;, age=&quot;</span> + age + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略构造器与Getter Setter</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在IntelliJ IDEA中，可以点击<code>Code</code>菜单中的 <code>Generate...</code>，也可以使用快捷键 <code>alt+insert</code>，点击 <code>toString()</code>选项。选择需要包含的成员变量并确定.</p>
<blockquote>
<p>小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。</p>
</blockquote>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><h4 id="方法摘要-1"><a href="#方法摘要-1" class="headerlink" title="方法摘要"></a>方法摘要</h4><ul>
<li><code>public boolean equals(Object obj)</code>：指示其他某个对象是否与此对象“相等”。</li>
</ul>
<p>调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。</p>
<h4 id="默认地址比较"><a href="#默认地址比较" class="headerlink" title="默认地址比较"></a>默认地址比较</h4><p>如果没有覆盖重写equals方法，那么Object类中默认进行<code>==</code>运算符的对象地址比较，只要不是同一个对象，结果必然为false。</p>
<h4 id="对象内容比较"><a href="#对象内容比较" class="headerlink" title="对象内容比较"></a>对象内容比较</h4><p>如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Objects;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;	<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>	<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-comment">// 如果对象地址一样，则认为相同</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果参数为空，或者类型信息不一样，则认为不同</span><br>        <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 转换为当前类型</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) o;<br>        <span class="hljs-comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span><br>        <span class="hljs-type">return</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span>= person.age &amp;&amp; Objects.equals(name, person.name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用 <code>Code</code> 菜单中的 <code>Generate…</code> 选项，也可以使用快捷键 <code>alt+insert </code>，并选择 <code>equals() and hashCode()</code> 进行自动代码生成。</p>
<h3 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h3><p>在刚才IDEA自动重写equals代码中，使用到了<code>java.util.Objects</code>类，那么这个类是什么呢？</p>
<p>在<strong>JDK7</strong>添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。</p>
<p>在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：</p>
<ul>
<li><code>public static boolean equals(Object a, Object b)</code>:判断两个对象是否相等。</li>
</ul>
<p>我们可以查看一下源码，学习一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object a, Object b)</span> &#123;  <br>    <span class="hljs-keyword">return</span> (a == b) || (a != <span class="hljs-literal">null</span> &amp;&amp; a.equals(b));  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><hr>
<h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3><h4 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h4><p><code>java.util.Date</code> 类 表示特定的瞬间，精确到毫秒。</p>
<ul>
<li><code>public Date()</code> ：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。<strong>获取的就是当前系统的日期和时间</strong>。</li>
<li><code>public Date(long date)</code> : 分配 <code>Date</code> 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日  00:00:00 GMT）以来的指定毫秒数。<strong>传递毫秒值，把毫秒值转换为Date日期</strong>。</li>
</ul>
<blockquote>
<p>tips：由于中国处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Date</span> &#123;<br>    <span class="hljs-comment">//创建日期对象，获取当前系统时间</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    <span class="hljs-comment">//创建日期对象，把传递的毫秒值转换成日期对象</span><br>    System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0L</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>tips：在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p>
</blockquote>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><p>Date类中的多数方法已经过时，常用的方法有：</p>
<ul>
<li><code>public long getTime()</code> ：把时间对象转换成对应的时间毫秒值（相当于<code>System.currentTimeMillis()</code>）。</li>
</ul>
<h3 id="DateFormat类"><a href="#DateFormat类" class="headerlink" title="DateFormat类"></a>DateFormat类</h3><p><code>java.text.DateFormat</code> 是日期&#x2F;时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本直之间的转换，也就是可以在Date对象与String对象之间进行来回转换。</p>
<ul>
<li><strong>格式化</strong>：按照指定的格式，从Date对象转换为String对象</li>
<li><strong>解析</strong>：按照指定的格式，从String对象转换为Date对象。</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类 <code>java.text.SimpleDateFormat</code> .这个类需要以一个模式（格式）来指定格式化或解析的标准。</p>
<ul>
<li><code>Public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语音环境的日期格式符号构造SimpleDateFormat。</li>
</ul>
<p>参数pattern是一个字符串，代表日期时间的自定义格式。</p>
<h4 id="格式规则"><a href="#格式规则" class="headerlink" title="格式规则"></a>格式规则</h4><p>常用的格式规则为：</p>
<table>
<thead>
<tr>
<th>标识字母（区分大小写）</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>年</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>d</td>
<td>日</td>
</tr>
<tr>
<td>H</td>
<td>时</td>
</tr>
<tr>
<td>m</td>
<td>分</td>
</tr>
<tr>
<td>s</td>
<td>秒</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。</p>
</blockquote>
<p>创建SimpleDateFormat对象的代码如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02SimpleDateFormat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//对应的日期格式如：2018-01-16 15:06:38</span><br>        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">format</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><p>DateFormat类的常用方法有：</p>
<ul>
<li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li>
<li><code>Public Date parse(String source)</code>：将字符串解析为Date对象。</li>
</ul>
<h5 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h5><p>使用format方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 把Date对象转换成String</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03DateFormatMethod</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">//创建日期格式化对象，在获取格式化对象时可以指定风格</span><br>        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> df.format(date);<br>        System.out.println(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h5><p>使用parse方法的代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02SimpleDateFormat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParseException &#123;<br>        <span class="hljs-type">DateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy年MM月dd日&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span>  <span class="hljs-operator">=</span> <span class="hljs-string">&quot;2021年08月23日&quot;</span>;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> df.parse(str);<br>        System.out.println(date);<span class="hljs-comment">//Mon Aug 23 00:00:00 CST 2021</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：parse方法声明了一个异常叫做ParseException解析异常，如果字符串和构造方法中的模式不一样，那么程序就会抛出此异常，调用一个抛出了异常的方法，就必须处理这个异常，要么throws继续声明抛出了一个异常，要么try…catch自己处理这个异常</p>
</blockquote>
<h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><h3 id="概述-18"><a href="#概述-18" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.Calendar</code>是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。</p>
<p>Calendar类是一个抽象类，里面提供了很多操作日历字段的方法（YEAR、MONTH、DAY_OF、HOUR）。</p>
<h4 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h4><p>Calendar类无法直接创建对象使用，里边有一个静态方法叫 <code>getInstance()</code> ,该烦烦烦返回了Calendar类的子类对象。</p>
<ul>
<li><code>public static Calendar getInstance()</code> ：使用默认时区和语言环境获得一个日历</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Calendar;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo06CalendarInit</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>public int get(int field):</code> 返回给定日历字段的值。</li>
<li><code>public void set(int field,int value):</code> 将给定的日历字段设置为给定值。</li>
<li><code>public abstract void add(int field,int amount):</code> 根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime():</code> 返回一个表示此Calendar时间值（从历元到现在的毫秒偏移值）的Date对象。</li>
</ul>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th>字段值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
</tr>
<tr>
<td>MONTH</td>
<td>月（从0开始，可以+1使用）</td>
</tr>
<tr>
<td>DAY_OF_MONTH</td>
<td>月中的天（几号）</td>
</tr>
<tr>
<td>HOUR</td>
<td>时（12小时制）</td>
</tr>
<tr>
<td>HOUR_OF_DAY</td>
<td>时（24小时制）</td>
</tr>
<tr>
<td>MINUTE</td>
<td>分</td>
</tr>
<tr>
<td>SECOND</td>
<td>秒</td>
</tr>
<tr>
<td>DAY_OF_WEEK</td>
<td>周中的天（周几，周日为1，可以-1使用）</td>
</tr>
</tbody></table>
<blockquote>
<p>小贴士：</p>
<p>​     西方星期的开始为周日，中国为周一。</p>
<p>​     在Calendar类中，月份的表示是以0-11代表1-12月。</p>
<p>​     日期是有大小关系的，时间靠后，时间越大。</p>
</blockquote>
<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2><p><code>java.lang.System</code>类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：</p>
<ul>
<li><p><code>public static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间。</p>
</li>
<li><p><code>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：将数组中指定的数据拷贝到另一个数组中。</p>
<p>数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数序号</th>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>2</td>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>3</td>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>4</td>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>5</td>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h2 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h2><h3 id="概述-19"><a href="#概述-19" class="headerlink" title="概述"></a>概述</h3><p>StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p>
<p>原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p>
<p>它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/StringBuilder%E7%9A%84%E5%8E%9F%E7%90%86.bmp" srcset="/img/loading.gif" lazyload></p>
<h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li><code>public StringBuilder()</code>：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。</li>
</ul>
<h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><p><code>public StringBuilder append(...)</code>：添加任意类型数据的字符串形式，并返回当前对象自身。</p>
<blockquote>
<p>append方法具有多种重载形式，可以接收任意类型的参数。</p>
</blockquote>
</li>
<li><p><code>public StringBuilder reverse()</code>：将此字符序列用其反转形式取代。</p>
</li>
<li><p><code>public String toString()</code>：将当前StringBuilder对象转换为String对象。</p>
</li>
</ul>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><h3 id="概述-20"><a href="#概述-20" class="headerlink" title="概述"></a>概述</h3><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的包装类（位于java.lang包中）</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td><strong>Character</strong></td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5.bmp" srcset="/img/loading.gif" lazyload></p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p>
<ul>
<li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li>
<li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li>
</ul>
<p>用Integer与 int为例：</p>
<p>基本数值—-&gt;包装对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">in1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//使用构造函数</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">in2</span> <span class="hljs-operator">=</span> Integer.valueof(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueof方法</span><br></code></pre></td></tr></table></figure>

<p>包装对象—-&gt;基本数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure>

<h3 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h3><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure>

<h2 id="基本类型与字符串之间的转换"><a href="#基本类型与字符串之间的转换" class="headerlink" title="基本类型与字符串之间的转换"></a>基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><p>基本类型转换String总共有三种方式 </p>
<ul>
<li>基本类型直接与””相连接即可；如：34+””（最常用）</li>
<li>使用包装类中的静态方法 <code>public static String toString(int i)</code>：返回一个表示指定整数的 <code>String</code> 对象</li>
<li>使用String类中的静态方法 <code>public static String valueOf()</code></li>
</ul>
<h3 id="String转换成对应的基本类型"><a href="#String转换成对应的基本类型" class="headerlink" title="String转换成对应的基本类型"></a>String转换成对应的基本类型</h3><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p>
<ul>
<li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li>
<li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li>
<li><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</li>
<li><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</li>
<li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li>
<li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li>
<li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li>
</ul>
<p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo18WrapperParse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;100&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出<code>java.lang.NumberFormatException</code>异常。</p>
</blockquote>
<h2 id="Collection集合"><a href="#Collection集合" class="headerlink" title="Collection集合"></a>Collection集合</h2><h3 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h3><ul>
<li>集合：是java中提供的一种容器，可以用来存储多个数据。</li>
</ul>
<p>集合和数组的区别：</p>
<ol>
<li>数组的长度是固定的。集合的长度是可变的。</li>
<li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li>
</ol>
<h3 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h3><p>JAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。</p>
<p>集合按照其存储结构可以分为两大类，分别是单列集合<code>java.util.Collection</code>和双列集合<code>java.util.Map</code>。</p>
<ul>
<li><strong>Collection</strong>：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是<code>java.util.List</code>和<code>java.util.Set</code>。其中，<code>List</code>的特点是元素有序、元素可重复。<code>Set</code>的特点是元素无序，而且不可重复。<code>List</code>接口的主要实现类有<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code>，<code>Set</code>接口的主要实现类有<code>java.util.HashSet</code>和<code>java.util.TreeSet</code>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.bmp" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h3><p>Collection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><p>在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口<code>java.util.Iterator</code>。<code>Iterator</code>接口也是Java集合中的一员，但它与<code>Collection</code>、<code>Map</code>接口有所不同，<code>Collection</code>接口与<code>Map</code>接口主要用于存储元素，而<code>Iterator</code>主要用于迭代访问（即遍历）<code>Collection</code>中的元素，因此<code>Iterator</code>对象也被称为迭代器。</p>
<h3 id="迭代的概念"><a href="#迭代的概念" class="headerlink" title="迭代的概念"></a>迭代的概念</h3><ul>
<li><strong>迭代</strong>：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</li>
</ul>
<h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<h3 id="迭代器的实现原理"><a href="#迭代器的实现原理" class="headerlink" title="迭代器的实现原理"></a>迭代器的实现原理</h3><p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.bmp" srcset="/img/loading.gif" lazyload></p>
<h3 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h3><p>增强for循环(也称for each循环)是<strong>JDK1.5</strong>以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; <br>  	<span class="hljs-comment">//写操作代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</p>
<p>tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。</p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="概述-21"><a href="#概述-21" class="headerlink" title="概述"></a>概述</h3><p><strong>泛型</strong>：可以在类或方法中预支地使用未知的类型。</p>
<blockquote>
<p>tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5.bmp" srcset="/img/loading.gif" lazyload></p>
<h4 id="创建集合对象，不使用泛型"><a href="#创建集合对象，不使用泛型" class="headerlink" title="创建集合对象，不使用泛型"></a>创建集合对象，不使用泛型</h4><ul>
<li>好处：集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据</li>
<li>弊端：不安全，会引发异常</li>
</ul>
<h4 id="创建集合对象，使用泛型"><a href="#创建集合对象，使用泛型" class="headerlink" title="创建集合对象，使用泛型"></a>创建集合对象，使用泛型</h4><ul>
<li>好处：<ol>
<li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li>
<li>把运行期异常（代码运行之后会抛出的异常），提升到了编译期（写代码的时候就会报错）</li>
</ol>
</li>
<li>弊端：泛型是什么类型，就只能存储什么类型的数据</li>
</ul>
<h3 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h3><p>当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<code>&lt;?&gt;</code>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</p>
<h4 id="通配符基本使用"><a href="#通配符基本使用" class="headerlink" title="通配符基本使用"></a>通配符基本使用</h4><p>泛型的通配符:<strong>不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。</strong></p>
<p>此时只能接受数据,不能往该集合中存储数据。</p>
<h3 id="通配符高级使用—-受限泛型"><a href="#通配符高级使用—-受限泛型" class="headerlink" title="通配符高级使用—-受限泛型"></a>通配符高级使用—-受限泛型</h3><p>之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的<strong>上限</strong>和<strong>下限</strong>。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li><strong>格式</strong>： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li><strong>意义</strong>： <code>只能接收该类型及其父类型</code></li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h3><p>数据存储的常用结构有：栈、队列、数组、链表和红黑树。我们分别来了解一下：</p>
<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul>
<li><strong>栈</strong>：<strong>stack</strong>,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其他任何位置进行添加、查找、删除等操作。</li>
</ul>
<p>简单的说：采用该结构的集合，对元素的存取有如下的特点</p>
<ul>
<li><p>先进后出（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</p>
</li>
<li><p>栈的入口、出口的都是栈的顶端位置。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%A0%86%E6%A0%88.png" srcset="/img/loading.gif" lazyload></p>
<p>这里两个名词需要注意：</p>
<ul>
<li><strong>压栈</strong>：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li><strong>弹栈</strong>：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><ul>
<li><strong>队列</strong>：<strong>queue</strong>,简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>先进先出（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，小火车过山洞，车头先进去，车尾后进去；车头先出来，车尾后出来。</li>
<li>队列的入口、出口各占一侧。例如，下图中的左侧为入口，右侧为出口。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E9%98%9F%E5%88%97%E5%9B%BE.bmp" srcset="/img/loading.gif" lazyload></p>
<h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><ul>
<li><strong>数组</strong>:<strong>Array</strong>,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</li>
</ul>
<p>简单的说,采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li>查找元素快：通过索引，可以快速访问指定位置的元素</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%95%B0%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%BF%AB.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>增删元素慢<ul>
<li><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。<img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%95%B0%E7%BB%84%E6%B7%BB%E5%8A%A0.png" srcset="/img/loading.gif" lazyload></li>
<li><strong>指定索引位置删除元素：</strong>将指定索引位置后的元素全部向前移动一位。<img src="https://raw.githubusercontent.com/zhstzzy/images/main/img/Java/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4.png" srcset="/img/loading.gif" lazyload></li>
</ul>
</li>
</ul>
<h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><ul>
<li><strong>链表</strong>:<strong>linked list</strong>,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的链表结构有单向链表与双向链表，那么这里给大家介绍的是<strong>单向链表</strong>。<img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E7%89%B9%E7%82%B9.png" srcset="/img/loading.gif" lazyload></li>
</ul>
<p>简单的说，采用该结构的集合，对元素的存取有如下的特点：</p>
<ul>
<li><p>多个结点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素</p>
</li>
<li><p>增删元素快：</p>
<ul>
<li><p>增加元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%A2%9E%E5%8A%A0%E7%BB%93%E7%82%B9.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>删除元素：只需要修改连接下个元素的地址即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9.bmp" srcset="/img/loading.gif" lazyload></p>
</li>
</ul>
</li>
</ul>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li><strong>二叉树</strong>：<strong>binary tree</strong> ,是每个结点不超过2的有序<strong>树（tree）</strong> 。</li>
</ul>
<p>简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都最多只能有两个子结点。</p>
<p>二叉树是每个节点最多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E4%BA%8C%E5%8F%89%E6%A0%91.bmp" srcset="/img/loading.gif" lazyload></p>
<p>我们要说的是二叉树的一种比较有意思的叫做<strong>红黑树</strong>，红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</p>
<p>红黑树的约束:</p>
<ol>
<li><p>节点可以是红色的或者黑色的</p>
</li>
<li><p>根节点是黑色的</p>
</li>
<li><p>叶子节点(特指空节点)是黑色的</p>
</li>
<li><p>每个红色节点的子节点都是黑色的</p>
</li>
<li><p>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</p>
</li>
</ol>
<p>红黑树的特点:</p>
<p>​	速度特别快,趋近平衡树,查找叶子元素最少和最多次数不多于二倍</p>
<h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><h3 id="概述-22"><a href="#概述-22" class="headerlink" title="概述"></a>概述</h3><p><code>java.util.List</code>接口继承自<code>Collection</code>接口，是单列集合的一个重要分支，习惯性地会将实现了<code>List</code>接口的对象称为List集合。在List集合中允许出现重复的元素，所有的元素是以一种线性方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List集合还有一个特点就是元素有序，即元素的存入顺序和取出顺序一致。</p>
<p>List接口特点：</p>
<ol>
<li>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</li>
<li>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</li>
<li>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</li>
</ol>
<blockquote>
<p>tips:我们在基础班的时候已经学习过List接口的子类java.util.ArrayList类，该类中的方法都是来自List中定义。</p>
</blockquote>
<h3 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>public void add(int index, E element)</code>: 将指定的元素，添加到该集合中的指定位置上。</li>
<li><code>public E get(int index)</code>:返回集合中指定位置的元素。</li>
<li><code>public E remove(int index)</code>: 移除列表中指定位置的元素, 返回的是被移除的元素。</li>
<li><code>public E set(int index, E element)</code>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</li>
</ul>
<h2 id="List的子类"><a href="#List的子类" class="headerlink" title="List的子类"></a>List的子类</h2><h3 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h3><p><code>java.util.ArrayList</code>集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以<code>ArrayList</code>是最常用的集合。</p>
<p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p>
<h3 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h3><p><code>java.util.LinkedList</code>集合数据存储的结构是链表结构。方便元素添加、删除的集合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>public void addFirst(E e)</code>:将指定元素插入此列表的开头。</li>
<li><code>public void addLast(E e)</code>:将指定元素添加到此列表的结尾。</li>
<li><code>public E getFirst()</code>:返回此列表的第一个元素。</li>
<li><code>public E getLast()</code>:返回此列表的最后一个元素。</li>
<li><code>public E removeFirst()</code>:移除并返回此列表的第一个元素。</li>
<li><code>public E removeLast()</code>:移除并返回此列表的最后一个元素。</li>
<li><code>public E pop()</code>:从此列表所表示的堆栈处弹出一个元素。</li>
<li><code>public void push(E e)</code>:将元素推入此列表所表示的堆栈。</li>
<li><code>public boolean isEmpty()</code>：如果列表不包含元素，则返回true。</li>
</ul>
<blockquote>
<p>在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p>
</blockquote>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><code>java.util.Set</code>接口和<code>java.util.List</code>接口一样，同样继承自<code>Collection</code>接口，它与<code>Collection</code>接口中的方法基本一致，并没有对<code>Collection</code>接口进行功能上的扩充，只是比<code>Collection</code>接口更加严格了。与<code>List</code>接口不同的是，<code>Set</code>接口中元素无序，并且都会以某种规则保证存入的元素不出现重复。</p>
<p><code>Set</code>集合有多个子类，这里我们介绍其中的<code>java.util.HashSet</code>、<code>java.util.LinkedHashSet</code>这两个集合。</p>
<blockquote>
<p>tips:Set集合取出元素的方式可以采用：迭代器、增强for。</p>
</blockquote>
<h3 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h3><h4 id="概述-23"><a href="#概述-23" class="headerlink" title="概述"></a>概述</h4><p><code>java.util.HashSet</code>是<code>Set</code>接口的一个实现类，它所存储的元素是<strong>不可重复</strong>的，并且元素都是无序的(即存取顺序不一致)。<code>java.util.HashSet</code>底层的实现其实是一个<code>java.util.HashMap</code>支持。</p>
<p><code>HashSet</code>是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：<code>hashCode</code>与<code>equals</code>方法。</p>
<h4 id="存储数据的结构（哈希表）"><a href="#存储数据的结构（哈希表）" class="headerlink" title="存储数据的结构（哈希表）"></a>存储数据的结构（哈希表）</h4><p>什么是哈希表呢？</p>
<p>在<strong>JDK1.8</strong>之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%93%88%E5%B8%8C%E8%A1%A8.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%93%88%E5%B8%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload></p>
<p>总而言之，<strong>JDK1.8</strong>引入红黑树大程度优化了HashMap的性能，那么对于我们来讲保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p>
<h4 id="自定义类型元素"><a href="#自定义类型元素" class="headerlink" title="自定义类型元素"></a>自定义类型元素</h4><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p>
<h3 id="LinkedHashSet集合"><a href="#LinkedHashSet集合" class="headerlink" title="LinkedHashSet集合"></a>LinkedHashSet集合</h3><p>在HashSet下面有一个子类<code>java.util.LinkedHashSet</code>，它是链表和哈希表组合的一个数据存储结构。</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>在<strong>JDK1.5</strong>之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">修饰符 返回值类型 方法名(参数类型... 形参名)</span><span class="hljs-template-variable">&#123;  &#125;</span><br></code></pre></td></tr></table></figure>

<p>其实这个书写完全等价与</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">修饰符 返回值类型 方法名(参数类型<span class="hljs-selector-attr">[]</span> 形参名)&#123;  &#125;<br></code></pre></td></tr></table></figure>

<p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p>
<p><strong>JDK1.5</strong>以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p>
<p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p>
<blockquote>
<p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p>
</blockquote>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><h3 id="常用功能-1"><a href="#常用功能-1" class="headerlink" title="常用功能"></a>常用功能</h3><ul>
<li><code>java.utils.Collections</code>是集合工具类，用来对集合进行操作。部分方法如下：</li>
</ul>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements)  </code>:往集合中添加一些元素。</li>
<li><code>public static void shuffle(List&lt;?&gt; list) 打乱顺序</code>:打乱集合顺序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>:将集合中元素按照指定规则排序。</li>
</ul>
<h3 id="Comparator比较器"><a href="#Comparator比较器" class="headerlink" title="Comparator比较器"></a>Comparator比较器</h3><p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>:将集合中元素按照默认规则排序。</p>
<p>说到排序了，简单的说就是两个对象之间比较大小，那么在JAVA中提供了两种比较实现的方式，一种是比较死板的采用<code>java.lang.Comparable</code>接口去实现，一种是灵活的当我需要做排序的时候在去选择的<code>java.util.Comparator</code>接口完成。</p>
<p>那么我们采用的<code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>这个方法完成的排序，实际上要求了被排序的类型需要实现Comparable接口完成比较的功能。</p>
<p><code>public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; )</code>方法灵活的完成，这个里面就涉及到了Comparator这个接口，位于位于java.util包下，排序是comparator能实现的功能之一,该接口代表一个比较器，比较器具有可比性！顾名思义就是做排序的，通俗地讲需要比较两个对象谁排在前谁排在后，那么比较的方法就是：</p>
<ul>
<li><p><code> public int compare(String o1, String o2)</code>：比较其两个参数的顺序。</p>
<blockquote>
<p>两个对象比较的结果有三种：大于，等于，小于。</p>
<p>如果要按照升序排序，<br>则o1 小于o2，返回（负数），相等返回0，01大于02返回（正数）<br>如果要按照降序排序<br>则o1 小于o2，返回（正数），相等返回0，01大于02返回（负数）</p>
</blockquote>
</li>
</ul>
<h3 id="Comparable和Comparator的区别。"><a href="#Comparable和Comparator的区别。" class="headerlink" title="Comparable和Comparator的区别。"></a>Comparable和Comparator的区别。</h3><p><strong>Comparable</strong>：强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法被称为它的自然比较方法。只能在类中实现compareTo()一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表（和数组）可以通过Collections.sort（和Arrays.sort）进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<p><strong>Comparator</strong>强行对某个对象进行整体排序。可以将Comparator 传递给sort方法（如Collections.sort或 Arrays.sort），从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序。</p>
<h2 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h2><h3 id="概述-24"><a href="#概述-24" class="headerlink" title="概述"></a>概述</h3><p>现实生活中，我们常会看到这样的一种集合：IP地址与主机名，身份证号与个人，系统用户名与系统用户对象等，这种一一对应的关系，就叫做映射。Java提供了专门的集合类用来存放这种对象关系的对象，即<code>java.util.Map</code>接口。</p>
<p>我们通过查看<code>Map</code>接口描述，发现<code>Map</code>接口下的集合与<code>Collection</code>接口下的集合，它们存储数据的形式不同，如下图。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/Collection%E4%B8%8EMap.bmp" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><code>Collection</code>中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li>
<li><code>Map</code>中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。</li>
<li>需要注意的是，<code>Map</code>中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
<h3 id="常用子类"><a href="#常用子类" class="headerlink" title="常用子类"></a>常用子类</h3><ul>
<li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
<li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li>
</ul>
<blockquote>
<p>tips：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</p>
</blockquote>
<h3 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li><code>public V put(K key, V value)</code>:  把指定的键与指定的值添加到Map集合中。</li>
<li><code>public V remove(Object key)</code>: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</li>
<li><code>public V get(Object key)</code> 根据指定的键，在Map集合中获取对应的值。</li>
<li><code>boolean containsKey(Object key)  </code> 判断集合中是否包含指定的键。</li>
<li><code>public Set&lt;K&gt; keySet()</code>: 获取Map集合中所有的键，存储到Set集合中。</li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h3 id="集合遍历"><a href="#集合遍历" class="headerlink" title="集合遍历"></a>集合遍历</h3><h4 id="键找值方式"><a href="#键找值方式" class="headerlink" title="键找值方式"></a>键找值方式</h4><p>键找值方式：即通过元素中的键，获取键所对应的值</p>
<p>步骤：</p>
<ol>
<li>获取Map中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键。方法提示:<code>keyset()</code></li>
<li>遍历键的Set集合，得到每一个键。</li>
<li>根据键，获取键所对应的值。方法提示:<code>get(K key)</code></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%B8%80.bmp" srcset="/img/loading.gif" lazyload></p>
<h4 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h4><p>我们已经知道，<code>Map</code>中存放的是两种对象，一种称为<strong>key</strong>(键)，一种称为<strong>value</strong>(值)，它们在在<code>Map</code>中是一一对应关系，这一对对象又称做<code>Map</code>中的一个<code>Entry(项)</code>。<code>Entry</code>将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历<code>Map</code>集合时，就可以从每一个键值对（<code>Entry</code>）对象中获取对应的键与对应的值。</p>
<p> 既然Entry表示了一对键和值，那么也同样提供了获取对应键和对应值得方法：</p>
<ul>
<li><code>public K getKey()</code>：获取Entry对象中的键。</li>
<li><code>public V getValue()</code>：获取Entry对象中的值。</li>
</ul>
<p>在Map集合中也提供了获取所有Entry对象的方法：</p>
<ul>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>: 获取到Map集合中所有的键值对对象的集合(Set集合)。</li>
</ul>
<h4 id="键值对方式"><a href="#键值对方式" class="headerlink" title="键值对方式"></a>键值对方式</h4><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p>
<p>步骤：</p>
<ol>
<li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。方法提示:<code>entrySet()</code>。</p>
</li>
<li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象。</p>
</li>
<li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。  方法提示:<code>getkey() getValue()</code></p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/Map%E9%9B%86%E5%90%88%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F%E4%BA%8C.bmp" srcset="/img/loading.gif" lazyload></p>
<blockquote>
<p>Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p>
</blockquote>
<h3 id="存储自定义类型键值"><a href="#存储自定义类型键值" class="headerlink" title="存储自定义类型键值"></a>存储自定义类型键值</h3><ul>
<li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li>
<li>如果要保证map中存放的key和取出的顺序一致，可以使用<code>java.util.LinkedHashMap</code>集合来存放。</li>
</ul>
<h2 id="LinkedHashMap集合"><a href="#LinkedHashMap集合" class="headerlink" title="LinkedHashMap集合"></a>LinkedHashMap集合</h2><p>在HashMap下面有一个子类LinkedHashMap，它是链表和哈希表组合的一个数据存储结构。（保证成对元素唯一，并且查询速度很快）</p>
<h2 id="Debug追踪"><a href="#Debug追踪" class="headerlink" title="Debug追踪"></a>Debug追踪</h2><p><strong>使用IDEA的断点调试功能，查看程序的运行过程</strong></p>
<ol>
<li><p>在有效代码行，点击行号右边的空白区域，设置断点，程序执行到断点将停止，我们可以手动来运行程序</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug1.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>点击Debug运行模式    </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug2.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>程序停止在断点上不再执行，而IDEA最下方打开了Debug调试窗口  </p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug3.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug4.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>Debug调试窗口介绍</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug5.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8，代码向下执行一行,第九行执行完毕，执行到第10行（第10行还未执行）</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug6.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>切换到控制台面板，控制台显示 请录入一个字符串： 并且等待键盘录入</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug7.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8，程序继续向后执行，执行键盘录入操作，在控制台录入数据 ababcea</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug8.png" srcset="/img/loading.gif" lazyload></p>
<p>回车之后效果：<img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug9.png" srcset="/img/loading.gif" lazyload></p>
<p>调试界面效果：<img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug10.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>此时到达findChar方法，快捷键F7，进入方法findChar</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug11.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8 接续执行，创建了map对象，变量区域显示</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug12.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8 接续执行，进入到循环中，循环变量i为 0,F8再继续执行，就获取到变量c赋值为字符‘a’ 字节值97</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug13.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8 接续执行，进入到判断语句中，因为该字符 不在Map集合键集中，再按F8执行，进入该判断中</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug14.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8 接续执行，循环结束，进入下次循环，此时map中已经添加一对儿元素</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug15.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>快捷键F8 接续执行，进入下次循环，再继续上面的操作，我们就可以看到代码每次是如何执行的了</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug16.png" srcset="/img/loading.gif" lazyload></p>
</li>
<li><p>如果不想继续debug,那么可以使用快捷键F9,程序正常执行到结束，程序结果在控制台显示</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/debug17.png" srcset="/img/loading.gif" lazyload></p>
</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是：</p>
<ul>
<li><strong>异常</strong> ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。</li>
</ul>
<p>在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。</p>
<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行.</p>
</blockquote>
<h3 id="体系"><a href="#体系" class="headerlink" title="体系"></a>体系</h3><p>异常机制其实是帮助我们<strong>找到</strong>程序中的问题，异常的根类是<code>java.lang.Throwable</code>，其下有两个子类：<code>java.lang.Error</code>与<code>java.lang.Exception</code>，平常所说的异常指<code>java.lang.Exception</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" srcset="/img/loading.gif" lazyload alt="异常体系"></p>
<p><strong>Throwable体系：</strong></p>
<ul>
<li><strong>Error</strong>:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。</li>
<li><strong>Exception</strong>:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。</li>
</ul>
<p><strong>Throwable中的常用方法：</strong></p>
<ul>
<li><p><code>public void printStackTrace()</code>:打印异常的详细信息。</p>
<p><em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
</li>
<li><p><code>public String getMessage()</code>:获取发生异常的原因。</p>
<p><em>提示给用户的时候,就提示错误原因。</em></p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
</ul>
<p><em><strong>出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。</strong></em></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%AE%80%E5%8D%95%E7%9A%84%E5%BC%82%E5%B8%B8%E6%9F%A5%E7%9C%8B.bmp" srcset="/img/loading.gif" lazyload alt="简单的异常查看"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。</p>
<p><strong>异常(Exception)的分类</strong>:根据在编译时期还是运行时期去检查异常?</p>
<ul>
<li><strong>编译时期异常</strong>:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常)</li>
<li><strong>运行时期异常</strong>:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB.png" srcset="/img/loading.gif" lazyload alt="异常的分类"></p>
<h3 id="异常的产生过程解析"><a href="#异常的产生过程解析" class="headerlink" title="异常的产生过程解析"></a>异常的产生过程解析</h3><p>先运行下面的程序，程序会产生一个数组索引越界异常 <code>ArrayIndexOfBoundsException</code> 。我们通过图解来解析下异常产生的过程。</p>
<p>工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayTools</span> &#123;<br>    <span class="hljs-comment">// 对给定的数组通过给定的角标获取元素。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> arr[index];<br>        <span class="hljs-keyword">return</span> element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123; <span class="hljs-number">34</span>, <span class="hljs-number">12</span>, <span class="hljs-number">67</span> &#125;;<br>        intnum = ArrayTools.getElement(arr, <span class="hljs-number">4</span>)<br>        System.out.println(<span class="hljs-string">&quot;num=&quot;</span> + num);<br>        System.out.println(<span class="hljs-string">&quot;over&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述程序执行过程图解：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90.bmp" srcset="/img/loading.gif" lazyload alt="异常产生过程解析"></p>
<h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><p>Java异常处理的五个关键字：<strong>try、catch、finally、throw、throws</strong></p>
<h4 id="抛出异常throw"><a href="#抛出异常throw" class="headerlink" title="抛出异常throw"></a>抛出异常throw</h4><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p>
<p>在java中，提供了一个<strong>throw</strong>关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p>
<ol>
<li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p>
</li>
<li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。</p>
<p>throw<strong>用在方法内</strong>，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p>
</li>
</ol>
<p><strong>使用格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> 异常类名(参数);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。</p>
<p>那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。</p>
</blockquote>
<h4 id="Objects非空判断"><a href="#Objects非空判断" class="headerlink" title="Objects非空判断"></a>Objects非空判断</h4><p><code>Objects</code>由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。</p>
<ul>
<li><code>public static &lt;T&gt; T requireNonNull(T obj)</code>:查看指定引用对象不是null。</li>
</ul>
<h4 id="声明异常throws"><a href="#声明异常throws" class="headerlink" title="声明异常throws"></a>声明异常throws</h4><p><strong>声明异常</strong>：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p>
<p>关键字<strong>throws</strong>运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常).</p>
<p><strong>声明异常格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数) <span class="hljs-keyword">throws</span> 异常类名<span class="hljs-number">1</span>,异常类名<span class="hljs-number">2</span>…&#123;   &#125;	<br></code></pre></td></tr></table></figure>

<h4 id="捕获异常try…catch"><a href="#捕获异常try…catch" class="headerlink" title="捕获异常try…catch"></a>捕获异常try…catch</h4><p>如果异常出现的话,会立刻终止程序,所以我们得处理异常:</p>
<ol>
<li>该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。</li>
<li>在方法中使用try-catch的语句块来处理异常。</li>
</ol>
<p><strong>try-catch</strong>的方式就是捕获异常。</p>
<ul>
<li><strong>捕获异常</strong>：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>	编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型  e)&#123;<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p>
<p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p>
<blockquote>
<p>注意:try和catch都不能单独使用,必须连用。</p>
</blockquote>
<h5 id="如何获取异常信息："><a href="#如何获取异常信息：" class="headerlink" title="如何获取异常信息："></a>如何获取异常信息：</h5><p>Throwable类中定义了一些查看方法:</p>
<ul>
<li><p><code>public String getMessage()</code>:获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。</p>
</li>
<li><p><code>public String toString()</code>:获取异常的类型和异常描述信息(不用)。</p>
</li>
<li><p><code>public void printStackTrace()</code>:打印异常的跟踪栈信息并输出到控制台。</p>
</li>
</ul>
<p>​            <em>包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。</em></p>
<h4 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h4><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p>
<p>什么时候的代码必须最终执行？</p>
<p>当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。</p>
<p>finally的语法:</p>
<p> try…catch….finally:自身需要处理异常,最终还得关闭资源。</p>
<blockquote>
<p>注意:finally不能单独使用。</p>
</blockquote>
<p>比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。</p>
<blockquote>
<p>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</p>
</blockquote>
<h4 id="异常注意事项"><a href="#异常注意事项" class="headerlink" title="异常注意事项"></a>异常注意事项</h4><ul>
<li><p>多个异常使用捕获又该如何处理呢？</p>
<ol>
<li>多个异常分别处理。</li>
<li>多个异常一次捕获，多次处理。</li>
<li>多个异常一次捕获一次处理。</li>
</ol>
<p>一般我们是使用一次捕获多次处理方式，格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>     编写可能会出现异常的代码<br>&#125;<span class="hljs-keyword">catch</span>(异常类型A  e)&#123;  当<span class="hljs-keyword">try</span>中出现A类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<span class="hljs-keyword">catch</span>(异常类型B  e)&#123;  当<span class="hljs-keyword">try</span>中出现B类型异常,就用该<span class="hljs-keyword">catch</span>来捕获.<br>     处理异常的代码<br>     <span class="hljs-comment">//记录日志/打印异常信息/继续抛出异常</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
</li>
<li><p>运行时异常被抛出可以不处理。即不捕获也不声明抛出。</p>
</li>
<li><p>如果finally有return语句,永远返回finally中的结果,避免该情况. </p>
</li>
<li><p>如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异常。</p>
</li>
<li><p>父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出</p>
</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><h4 id="概述-25"><a href="#概述-25" class="headerlink" title="概述"></a>概述</h4><p><strong>为什么需要自定义异常类:</strong></p>
<p>我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。例如年龄负数问题,考试成绩负数问题等等。</p>
<p>在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？</p>
<p><strong>什么是自定义异常类:</strong></p>
<p>在开发中根据自己业务的异常情况来定义异常类.</p>
<p>自定义一个业务逻辑异常: <strong>RegisterException</strong>。一个注册异常类。</p>
<p><strong>异常类如何定义:</strong></p>
<ol>
<li>自定义一个编译期异常: 自定义类 并继承于<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时期的异常类:自定义类 并继承于<code>java.lang.RuntimeException</code>。</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>我们在之前，学习的程序在没有跳转语句的前提下，都是由上至下依次执行，那现在想要设计一个程序，边打游戏边听歌，怎么设计？</p>
<p>要解决上述问题,咱们得使用多进程或者多线程来解决.</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.bmp" srcset="/img/loading.gif" lazyload alt="02_并发与并行"></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核 越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
<p><strong>进程</strong></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5.bmp" srcset="/img/loading.gif" lazyload alt="进程概念"></p>
<p><strong>线程</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5.bmp" srcset="/img/loading.gif" lazyload alt="线程概念"></p>
<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
</li>
</ul>
</li>
</ul>
<h3 id="创建线程类"><a href="#创建线程类" class="headerlink" title="创建线程类"></a>创建线程类</h3><blockquote>
<p>继承Thread类</p>
</blockquote>
<p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="多线程原理"><a href="#多线程原理" class="headerlink" title="多线程原理"></a>多线程原理</h3><p>流程图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%BA%BF%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="线程流程图"></p>
<p>程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用mt的对象的start方法，另外一个新的线程也启动了，这样，整个应用就在多线程下运行。<br>多线程执行时，到底在内存中是如何运行的呢？以上个程序为例，进行图解说明:<br>多线程执行时，在栈内存中，其实<strong>每一个执行线程都有一片自己所属的栈内存空间</strong>。进行方法的压栈和弹栈。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%A0%88%E5%86%85%E5%AD%98%E5%8E%9F%E7%90%86%E5%9B%BE.bmp" srcset="/img/loading.gif" lazyload alt="栈内存原理图">当执行线程的任务结束了，线程自动在栈内存中释放了。但是当所有的执行线程都结束了，那么进程就结束了。</p>
<h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>构造方法：</p>
<ul>
<li><code>public Thread()</code> :分配一个新的线程对象。</li>
<li><code>public Thread(String name)</code> :分配一个指定名字的新的线程对象。</li>
<li><code>public Thread(Runnable target)</code> :分配一个带有指定目标新的线程对象。</li>
<li><code>public Thread(Runnable target,String name)</code> :分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>public String getName()</code> :获取当前线程名称。</li>
<li><code>public void start()</code> :导致此线程开始执行; Java虚拟机调用此线程的run方法。</li>
<li><code>public void run()</code> :此线程要执行的任务在此处定义代码。</li>
<li><code>public static void sleep(long millis)</code> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</li>
<li><code>public static Thread currentThread()</code> :返回对当前正在执行的线程对象的引用。</li>
</ul>
<blockquote>
<p>创建线程的方式总共有两种，一种是继承Thread类方式，一种是实现Runnable接口方式</p>
</blockquote>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><blockquote>
<p>实现Runnable接口</p>
</blockquote>
<p>采用java.lang.Runnable 也是非常常见的一种，我们只需要重写run方法即可。<br>步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li>
<li>调用线程对象的start()方法来启动线程。</li>
</ol>
<p>通过实现Runnable接口，使得该类有了多线程类的特征。run()方法是多线程程序的一个执行目标。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。</p>
<p>在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。</p>
<p>实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。</p>
<blockquote>
<p>Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。</p>
</blockquote>
<h3 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h3><p>如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。</p>
<p><strong>总结：</strong><br>实现Runnable接口比继承Thread类所具有的优势：</p>
<ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>
<blockquote>
<p>在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM其实在就是在操作系统中启动了一个进程。</p>
</blockquote>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>
<blockquote>
<p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。</p>
</blockquote>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。</p>
<p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了**同步机制(synchronized)**来解决。</p>
<p>有三种方式完成同步操作：</p>
<ol>
<li>同步代码块。</li>
<li>同步方法。</li>
<li>锁机制。</li>
</ol>
<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><ul>
<li><strong>同步代码块</strong>： <code>synchronized</code> 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(同步锁)&#123;<br>    需要同步操作的代码<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>同步锁</strong>：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁.<ol>
<li>锁对象 可以是任意类型。</li>
<li>多个线程对象 要使用同一把锁。</li>
</ol>
</li>
</ul>
<blockquote>
<p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着<br>(BLOCKED)。</p>
</blockquote>
<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><ul>
<li><strong>同步方法</strong>:使用<code>synchronized</code>修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>	可能会产生线程安全问题的代码<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>同步锁是谁?</p>
<p>对于非static方法,同步锁就是this。</p>
<p>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。</p>
</blockquote>
<h4 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h4><p><code>java.util.concurrent.locks.Lock</code> 机制提供了比<strong>synchronized代码块</strong>和<strong>synchronized方法</strong>更广泛的锁定操作,同步代码块&#x2F;同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。</p>
<p>Lock锁也称同步锁，加锁与释放锁方法化了，如下：</p>
<ul>
<li><code>public void lock()</code> :加同步锁。</li>
<li><code>public void unlock()</code> :释放同步锁。</li>
</ul>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，有几种状态呢？在API中<code>java.lang.Thread.State</code> 这个枚举中给出了六种线程状态：</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>New(新建)</td>
<td>线程刚被创建，但是并未启动。还没调用start方法。</td>
</tr>
<tr>
<td>Runnable(可运行)</td>
<td>线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。</td>
</tr>
<tr>
<td>Blocked(锁阻塞)</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。</td>
</tr>
<tr>
<td>Waiting(无限等待)</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</td>
</tr>
<tr>
<td>Timed Waiting(计时等待)</td>
<td>同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。</td>
</tr>
<tr>
<td>Teminated(被终止)</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%9B%BE.bmp" srcset="/img/loading.gif" lazyload></p>
<h3 id="Timed-Waiting（计时等待）"><a href="#Timed-Waiting（计时等待）" class="headerlink" title="Timed Waiting（计时等待）"></a>Timed Waiting（计时等待）</h3><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。</p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等待).</p>
<ol>
<li>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</li>
<li>为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证该线程执行过程中会睡眠</li>
<li>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。</li>
</ol>
<blockquote>
<p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始立刻执行。</p>
</blockquote>
<p>Timed Waiting 线程状态图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85.png" srcset="/img/loading.gif" lazyload alt="计时等待"></p>
<h3 id="BLOCKED（锁阻塞）"><a href="#BLOCKED（锁阻塞）" class="headerlink" title="BLOCKED（锁阻塞）"></a>BLOCKED（锁阻塞）</h3><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。</p>
<p>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。</p>
<p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E9%94%81%E9%98%BB%E5%A1%9E.png" srcset="/img/loading.gif" lazyload alt="锁阻塞"></p>
<h3 id="Waiting（无限等待）"><a href="#Waiting（无限等待）" class="headerlink" title="Waiting（无限等待）"></a>Waiting（无限等待）</h3><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。</p>
<p>一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的Object.notify()方法 或 Object.notifyAll()方法。</p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系，多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85.png" srcset="/img/loading.gif" lazyload alt="无限等待"></p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="线程状态图"></p>
<blockquote>
<p>我们在翻阅API的时候会发现Timed Waiting（计时等待） 与 Waiting（无限等待） 状态联系还是很紧密的，比如Waiting（无限等待） 状态中wait方法是空参的，而timed waiting（计时等待） 中wait方法是带参的。这种带参的方法，其实是一种倒计时操作，相当于我们生活中的小闹钟，我们设定好时间，到时通知，可是如果提前得到（唤醒）通知，那么设定好时间在通知也就显得多此一举了，那么这种设计方案其实是一举两得。如果没有得到（唤醒）通知，那么线程就处于Timed Waiting状态,直到倒计时完毕自动醒来；如果在倒计时期间得到（唤醒）通知，那么线程从Timed Waiting状态立刻唤醒。</p>
</blockquote>
<h2 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h2><p><strong>线程间通信</strong></p>
<p><strong>概念：</strong>多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。</p>
<p>比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，那么线程A与线程B之间就存在线程通信问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.bmp" srcset="/img/loading.gif" lazyload alt="线程间通信"></p>
<p><strong>为什么要处理线程间通信：</strong></p>
<p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<p><strong>如何保证线程间通信有效利用资源：</strong></p>
<p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作。 就是多个线程在操作同一份数据时， 避免对同一共享变量的争夺。也就是我们需要通过一定的手段使各个线程能有效的利用资源。而这种手段即—— <strong>等待唤醒机制。</strong></p>
<h3 id="等待唤醒机制-1"><a href="#等待唤醒机制-1" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p><strong>什么是等待唤醒机制</strong></p>
<p>这是多个线程间的一种<strong>协作</strong>机制。谈到线程我们经常想到的是线程间的<strong>竞争（race）</strong>，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。就好比在公司里你和你的同事们，你们可能存在在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。</p>
<p>就是在一个线程进行了规定操作后，就进入等待状态（**wait()<strong>）， 等待其他线程执行完他们的指定代码过后 再将其唤醒（</strong>notify()**）;在有多个线程进行等待时， 如果需要，可以使用 notifyAll()来唤醒所有的等待线程。</p>
<p>wait&#x2F;notify 就是线程间的一种协作机制。</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用于解决线程间通信的问题的，使用到的3个方法的含义如下：</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态即是 WAITING。它还要等着别的线程执行一个<strong>特别的动作</strong>，也即是“<strong>通知（notify）</strong>”在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（ready queue）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个线程释放；例如，餐馆有空位置后，等候就餐最久的顾客最先入座。</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>哪怕只通知了一个等待的线程，被通知线程也不能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。</p>
<p>总结如下：</p>
<ul>
<li>如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE 状态；</li>
<li>否则，从 wait set 出来，又进入 entry set，线程就从 WAITING 状态又变成 BLOCKED 状态</li>
</ul>
</blockquote>
<p><strong>调用wait和notify方法需要注意的细节</strong></p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</li>
<li>wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所属类都是继承了Object类的。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用这2个方法。</li>
</ol>
<h3 id="生产者和消费者问题"><a href="#生产者和消费者问题" class="headerlink" title="生产者和消费者问题"></a>生产者和消费者问题</h3><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。</p>
<p>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为<span class="hljs-literal">false</span>），吃货线程等待，包子铺线程生产包子（即包子状态为<span class="hljs-literal">true</span>），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包子状态为<span class="hljs-literal">false</span>），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取决于锁的获取情况。<br></code></pre></td></tr></table></figure>



<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p>
<p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果。</p>
<h3 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h3><ul>
<li><strong>线程池：</strong>其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多赘述。我们通过一张图来了解线程池的工作原理：</p>
<p><img src="https://cdn.jsdelivr.net/gh/zhstzzy/images/img/Java/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86.bmp" srcset="/img/loading.gif" lazyload alt="线程池原理">合理利用线程池能够带来三个好处：</p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>Java里面线程池的顶级接口是<code>java.util.concurrent.Executor</code>，但是严格意义上讲<code>Executor</code>并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是<code>java.util.concurrent.ExecutorService</code>。</p>
<p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在<code>java.util.concurrent.Executors</code>线程工厂类里面提供了一些静态工厂，生成一些常用的线程池。官方建议使用Executors工程类来创建线程池对象。</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li><code>public static ExecutorService newFixedThreadPool(int nThreads)</code>：返回线程池对象。(创建的是有界线程池,也就是池中的线程个数可以指定最大数量)</li>
</ul>
<p>获取到了一个线程池ExecutorService 对象，那么怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li><p><code>public Future&lt;?&gt; submit(Runnable task)</code>:获取线程池中的某一个线程对象，并执行</p>
<blockquote>
<p>Future接口：用来记录线程任务执行完毕后产生的结果。线程池创建与使用。</p>
</blockquote>
</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li>创建线程池对象。</li>
<li>创建Runnable接口子类对象。(task)</li>
<li>提交Runnable接口子类对象。(take task)</li>
<li>关闭线程池(一般不做)。</li>
</ol>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="函数式编程思想概述"><a href="#函数式编程思想概述" class="headerlink" title="函数式编程思想概述"></a>函数式编程思想概述</h3><p>在数学中，<strong>函数</strong>就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，面向对象过分强调“必须通过对象的形式来做事情”，而函数式思想则尽量忽略面向对象的复杂语法——<strong>强调做什么，而不是以什么形式做</strong>。</p>
<p>面向对象的思想:</p>
<p>​	做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.</p>
<p>函数式编程思想:</p>
<p>​	只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程</p>
<h3 id="冗余的Runnable代码"><a href="#冗余的Runnable代码" class="headerlink" title="冗余的Runnable代码"></a>冗余的Runnable代码</h3><h4 id="传统写法"><a href="#传统写法" class="headerlink" title="传统写法"></a>传统写法</h4><p>当需要启动一个线程去完成任务时，通常会通过<code>java.lang.Runnable</code>接口来定义任务内容，并使用<code>java.lang.Thread</code>类来启动该线程。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01Runnable</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    	<span class="hljs-comment">// 匿名内部类</span><br>		<span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 覆盖重写抽象方法</span><br>				System.out.println(<span class="hljs-string">&quot;多线程任务执行！&quot;</span>);<br>			&#125;<br>		&#125;;<br>		<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start(); <span class="hljs-comment">// 启动线程</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本着“一切皆对象”的思想，这种做法是无可厚非的：首先创建一个<code>Runnable</code>接口的匿名内部类对象来指定任务内容，再将其交给一个线程来启动。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>对于<code>Runnable</code>的匿名内部类用法，可以分析出几点内容：</p>
<ul>
<li><code>Thread</code>类需要<code>Runnable</code>接口作为参数，其中的抽象<code>run</code>方法是用来指定线程任务内容的核心；</li>
<li>为了指定<code>run</code>的方法体，<strong>不得不</strong>需要<code>Runnable</code>接口的实现类；</li>
<li>为了省去定义一个<code>RunnableImpl</code>实现类的麻烦，<strong>不得不</strong>使用匿名内部类；</li>
<li>必须覆盖重写抽象<code>run</code>方法，所以方法名称、方法参数、方法返回值<strong>不得不</strong>再写一遍，且不能写错；</li>
<li>而实际上，<strong>似乎只有方法体才是关键所在</strong>。</li>
</ul>
<h3 id="编程思想转换"><a href="#编程思想转换" class="headerlink" title="编程思想转换"></a>编程思想转换</h3><h4 id="做什么，而不是怎么做"><a href="#做什么，而不是怎么做" class="headerlink" title="做什么，而不是怎么做"></a>做什么，而不是怎么做</h4><p>我们真的希望创建一个匿名内部类对象吗？不。我们只是为了做这件事情而<strong>不得不</strong>创建一个对象。我们真正希望做的事情是：将<code>run</code>方法体内的代码传递给<code>Thread</code>类知晓。</p>
<p><strong>传递一段代码</strong>——这才是我们真正的目的。而创建对象只是受限于面向对象语法而不得不采取的一种手段方式。那，有没有更加简单的办法？如果我们将关注点从“怎么做”回归到“做什么”的本质上，就会发现只要能够更好地达到目的，过程与形式其实并不重要。</p>
<h4 id="生活举例"><a href="#生活举例" class="headerlink" title="生活举例"></a>生活举例</h4><p>当我们需要从北京到上海时，可以选择高铁、汽车、骑行或是徒步。我们的真正目的是到达上海，而如何才能到达上海的形式并不重要，所以我们一直在探索有没有比高铁更好的方式——搭乘飞机。</p>
<p>而现在这种飞机（甚至是飞船）已经诞生：2014年3月Oracle所发布的Java 8（JDK 1.8）中，加入了<strong>Lambda表达式</strong>的重量级新特性，为我们打开了新世界的大门。</p>
<h2 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h2><p>Lambda省去面向对象的条条框框，格式由<strong>3个部分</strong>组成：</p>
<ul>
<li>一些参数</li>
<li>一个箭头</li>
<li>一段代码</li>
</ul>
<p>Lambda表达式的<strong>标准格式</strong>为：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(参数类型 参数名称)</span> -&gt;</span> &#123; 代码语句 &#125;<br></code></pre></td></tr></table></figure>

<p>格式说明：</p>
<ul>
<li>小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。</li>
<li><code>-&gt;</code>是新引入的语法格式，代表指向动作。</li>
<li>大括号内的语法与传统方法体要求基本一致。</li>
</ul>
<h3 id="Lambda的使用前提"><a href="#Lambda的使用前提" class="headerlink" title="Lambda的使用前提"></a>Lambda的使用前提</h3><p>Lambda的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意：</p>
<ol>
<li>使用Lambda必须具有接口，且要求<strong>接口中有且仅有一个抽象方法</strong>。<br>无论是JDK内置的<code>Runnable</code>、<code>Comparator</code>接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用Lambda。</li>
<li>使用Lambda必须具有<strong>上下文推断</strong>。<br>也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。</li>
</ol>
<blockquote>
<p>备注：有且仅有一个抽象方法的接口，称为“<strong>函数式接口</strong>”。</p>
</blockquote>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/java/" class="category-chain-item">java</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/">#java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>java</div>
      <div>http://example.com/2022/06/28/Java/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>zhstzzy</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年6月28日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/28/maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="maven生命周期">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">maven生命周期</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/06/28/%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/" title="声明式事务控制">
                        <span class="hidden-mobile">声明式事务控制</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>一只傻老马的博客 ｜ 记录学习的过程</div> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div>

    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
